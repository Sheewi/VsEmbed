{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAY;AACZ,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACtKY;AACZ,iBAAiB,mBAAO,CAAC,kDAAU;AACnC,WAAW,0DAA8B;AACzC,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,cAAc;AACd,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;;AAEA,kBAAkB;AAClB,sBAAsB;;AAEtB,mBAAmB;AACnB,uBAAuB;;;;;;;;;;;;ACraX;AACZ;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,sBAAQ;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,WAAW,2EAAuC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,wBAAwB;;AAExB,qBAAqB;AACrB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;;AAE1D;AACA,iCAAiC,YAAY;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxoBA;AACA;AACA;AACA;AACA,0BAA0B,mDAAyB;AACnD,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AClHW;;AAEZ,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,oDAAwB;AACvC,iBAAiB,mBAAO,CAAC,kBAAM;;AAE/B,kBAAkB,qGAA6C;AAC/D,iBAAiB,mBAAO,CAAC,kDAAU;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,yBAAyB;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,eAAe;AACf,YAAY;AACZ,cAAc;AACd,kBAAkB;AAClB,kBAAkB;AAClB,aAAa;AACb;AACA;AACA,EAAE,sBAAsB;AACxB,EAAE,wBAAwB;AAC1B,EAAE;AACF,EAAE,sBAAsB,GAAG,wBAAwB;AACnD;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3VA,gBAAgB,mBAAO,CAAC,gEAAmB;AAC3C,gBAAgB,mBAAO,CAAC,gEAAmB;;AAE3C,OAAO,gCAAgC,EAAE,mBAAO,CAAC,0EAAwB;AACzE,OAAO,gCAAgC,EAAE,mBAAO,CAAC,0EAAwB;AACzE,OAAO,0BAA0B,EAAE,mBAAO,CAAC,oEAAqB;;;AAGhE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;AC5BlB,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,UAAU,UAAU;AACzB,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;AC/DlB,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;AAChC,OAAO,wBAAwB,EAAE,mBAAO,CAAC,8DAAgB;AACzD,OAAO,gCAAgC,EAAE,mBAAO,CAAC,sEAAoB;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;ACtClB,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,kBAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC5BA,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;ACTN;;AAEZ;AACA,SAAS,GAAG,+FAA2C;AACvD,SAAS,GAAG,kGAA6C;AACzD,SAAS,GAAG,yFAAuC;AACnD,SAAS,GAAG,+FAA2C;AACvD,SAAS,GAAG,kGAA6C;;AAEzD;AACA,yFAAuC;AACvC,+FAA2C;AAC3C,4FAAyC;AACzC,0GAAkD;AAClD,6GAAoD;AACpD,+FAA2C;AAC3C,sFAAqC;AACrC,4FAAyC;;;;;;;;;;;;ACjB7B;;AAEZ;AACA,YAAY,mBAAO,CAAC,qEAAqB;;AAEzC,aAAa,mBAAO,CAAC,iDAAW;AAChC,YAAY,mBAAO,CAAC,wDAAa;AACjC,UAAU,mBAAO,CAAC,iDAAW;AAC7B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9GY;;AAEZ;AACA,YAAY,mBAAO,CAAC,qEAAqB;AACzC,eAAe,mBAAO,CAAC,qDAAa;AACpC,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,wDAAa;AACjC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,qFAA6B;;AAExD;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;;AAEA;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAO,CAAC,cAAI;;AAErD;AACA,QAAQ,kDAAkD;;AAE1D;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBY;AACZ;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,mDAAY;AAClC,mBAAmB,+CAAqB;AACxC,cAAc,mBAAO,CAAC,mEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/SY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC5BY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvGY;;AAEZ;AACA;;AAEA;AACA,YAAY,mBAAO,CAAC,qEAAqB;AACzC,eAAe,mBAAO,CAAC,mDAAY;AACnC,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,wDAAa;AACjC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,qFAA6B;;AAExD;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;AC1IY;AACZ;;AAEA;AACA;;AAEA,eAAe,mBAAO,CAAC,8CAAQ;AAC/B,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,+CAAQ;AAC/B,iBAAiB,mBAAO,CAAC,qFAA6B;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,MAAM;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpOY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACPY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,WAAW,EAAE,mBAAO,CAAC,mEAAU;AACvC,aAAa,mBAAO,CAAC,kDAAU;AAC/B,kBAAkB,mBAAO,CAAC,6DAAiB;AAC3C,mBAAmB,mBAAO,CAAC,+DAAkB;AAC7C;AACA;AACA,gBAAgB,mBAAO,CAAC,kDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,6DAAiB;AACxC,iBAAiB,mBAAO,CAAC,qFAA6B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/aY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,6DAAiB;AACxC,eAAe,mBAAO,CAAC,qDAAa;AACpC,WAAW,mBAAO,CAAC,sBAAQ;AAC3B,gBAAgB,mBAAO,CAAC,kDAAS;AACjC;AACA,cAAc,mBAAO,CAAC,6DAAiB;AACvC,YAAY,mBAAO,CAAC,+CAAU;AAC9B,aAAa,mBAAO,CAAC,kDAAU;AAC/B,QAAQ,WAAW,EAAE,mBAAO,CAAC,wBAAS;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,6DAA6D,QAAQ;AACrE,QAAQ;AACR,6DAA6D,QAAQ;AACrE,QAAQ;AACR;AACA;AACA,gEAAgE,QAAQ;AACxE,UAAU;AACV,iEAAiE,QAAQ;AACzE,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,+CAA+C;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB,MAAM,eAAe,OAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACviBD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,kBAAkB,mBAAO,CAAC,2EAAwB;AAClD,qBAAqB,mBAAO,CAAC,qFAA6B;AAC1D,QAAQ,OAAO,EAAE,mBAAO,CAAC,kBAAM;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,cAAc;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,WAAW;AACX;;;;;;;;;;;;AC3JY;AACZ,eAAe,mBAAO,CAAC,qDAAa;AACpC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,gCAAgC,gBAAgB;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrJY;AACZ,QAAQ,WAAW,EAAE,mBAAO,CAAC,mEAAU;AACvC,iBAAiB,mBAAO,CAAC,qFAA6B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GY;;AAEZ;AACA,YAAY,mBAAO,CAAC,qEAAqB;AACzC,aAAa,mBAAO,CAAC,iDAAW;AAChC,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,wDAAa;AACjC,UAAU,mBAAO,CAAC,iDAAW;AAC7B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,qDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,oBAAoB;AACrD,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrPA;AACA,QAAQ,oBAAoB,EAAE,+CAAqB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;;;;;;;;;;;;AC3CA;;AAEZ;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,mDAAY;AACnC,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,wDAAa;AACjC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,mDAAY;AAClC,WAAW,mBAAO,CAAC,yDAAe;AAClC,yBAAyB,mBAAO,CAAC,2EAAwB;AACzD,0BAA0B,mBAAO,CAAC,+EAA0B;AAC5D,iBAAiB,mBAAO,CAAC,qFAA6B;AACtD,mBAAmB,mBAAO,CAAC,qFAA6B;AACxD,kBAAkB,mBAAO,CAAC,2EAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B;AACA,cAAc,cAAc;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW,KAAK,OAAO;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC15BY;;AAEZ;;AAEA,YAAY,mBAAO,CAAC,qEAAqB;AACzC,UAAU,mBAAO,CAAC,uDAAc;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvCY;AACZ;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,oDAAoD,KAAK,IAAI,QAAQ;AACrE;AACA;AACA;;;;;;;;;;;;ACvBY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBY;AACZ,QAAQ,WAAW,EAAE,mBAAO,CAAC,mEAAU;AACvC,YAAY,mBAAO,CAAC,+CAAU;AAC9B,eAAe,mBAAO,CAAC,qDAAa;AACpC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,qFAA6B;AACtD,mBAAmB,mBAAO,CAAC,qFAA6B;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,6DAAiB;AACxC,iBAAiB,mBAAO,CAAC,yDAAe;AACxC,0BAA0B,mBAAO,CAAC,+EAA0B;;AAE5D,gBAAgB,mBAAO,CAAC,yDAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,+CAA+C,UAAU;AACzD;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjiBY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,sBAAQ;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,sBAAsB,mBAAO,CAAC,sCAAgB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;;AAE1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AAC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;;AAEA,SAAS,8DAAe;AACxB;;AAEA,iEAAe,EAAE,E;;;;;;;;;;;;;;;;;AC5BU;AACE;AAC7B,WAAW,mDAAG,aAAa,gDAAI;AAC/B,iEAAe,EAAE,E;;;;;;;;;;;;;;;;ACHc;;AAE/B;AACA,qCAAqC,iDAAK;AAC1C;;AAEA,iEAAe,QAAQ,E;;;;;;;;;;;;;;;;ACNc;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,OAAO,E;;;;;;;;;;;ACVV;AACZ;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;;;;;;;;;;;ACPY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6BAA6B;AACnE;AACA;AACA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA,SAAS,6BAA6B;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AAC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","sources":["webpack://vsembed-ai-devtool/./node_modules/chownr/chownr.js","webpack://vsembed-ai-devtool/./node_modules/fs-minipass/index.js","webpack://vsembed-ai-devtool/./node_modules/minipass/index.js","webpack://vsembed-ai-devtool/./node_modules/minizlib/constants.js","webpack://vsembed-ai-devtool/./node_modules/minizlib/index.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/index.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/find-made.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/mkdirp-manual.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/mkdirp-native.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/opts-arg.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/path-arg.js","webpack://vsembed-ai-devtool/./node_modules/mkdirp/lib/use-native.js","webpack://vsembed-ai-devtool/./node_modules/tar/index.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/create.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/extract.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/get-write-flag.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/header.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/high-level-opt.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/large-numbers.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/list.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/mkdir.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/mode-fix.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/normalize-unicode.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/normalize-windows-path.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/pack.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/parse.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/path-reservations.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/pax.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/read-entry.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/replace.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/strip-absolute-path.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/strip-trailing-slashes.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/types.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/unpack.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/update.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/warn-mixin.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/winchars.js","webpack://vsembed-ai-devtool/./node_modules/tar/lib/write-entry.js","webpack://vsembed-ai-devtool/./node_modules/tar/node_modules/minipass/index.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/index.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/md5.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/native.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/nil.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/parse.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/regex.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/rng.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/sha1.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/stringify.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/v1.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/v3.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/v35.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/v4.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/v5.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/validate.js","webpack://vsembed-ai-devtool/./node_modules/uuid/dist/esm-node/version.js","webpack://vsembed-ai-devtool/./node_modules/yallist/iterator.js","webpack://vsembed-ai-devtool/./node_modules/yallist/yallist.js","webpack://vsembed-ai-devtool/./src/main/main.ts","webpack://vsembed-ai-devtool/./src/services/AIOrchestratorService.ts","webpack://vsembed-ai-devtool/./src/services/EditorService.ts","webpack://vsembed-ai-devtool/./src/services/RunnerManager.ts","webpack://vsembed-ai-devtool/./src/services/SecretsManager.ts","webpack://vsembed-ai-devtool/./src/services/SecurityManager.ts","webpack://vsembed-ai-devtool/./src/services/TerminalService.ts","webpack://vsembed-ai-devtool/./src/services/WorkspaceManager.ts","webpack://vsembed-ai-devtool/external node-commonjs \"assert\"","webpack://vsembed-ai-devtool/external node-commonjs \"buffer\"","webpack://vsembed-ai-devtool/external node-commonjs \"child_process\"","webpack://vsembed-ai-devtool/external node-commonjs \"crypto\"","webpack://vsembed-ai-devtool/external commonjs2 \"dockerode\"","webpack://vsembed-ai-devtool/external commonjs2 \"electron\"","webpack://vsembed-ai-devtool/external node-commonjs \"events\"","webpack://vsembed-ai-devtool/external node-commonjs \"fs\"","webpack://vsembed-ai-devtool/external node-commonjs \"fs/promises\"","webpack://vsembed-ai-devtool/external node-commonjs \"os\"","webpack://vsembed-ai-devtool/external node-commonjs \"path\"","webpack://vsembed-ai-devtool/external node-commonjs \"process\"","webpack://vsembed-ai-devtool/external node-commonjs \"stream\"","webpack://vsembed-ai-devtool/external node-commonjs \"string_decoder\"","webpack://vsembed-ai-devtool/external node-commonjs \"util\"","webpack://vsembed-ai-devtool/external node-commonjs \"zlib\"","webpack://vsembed-ai-devtool/webpack/bootstrap","webpack://vsembed-ai-devtool/webpack/runtime/compat get default export","webpack://vsembed-ai-devtool/webpack/runtime/define property getters","webpack://vsembed-ai-devtool/webpack/runtime/hasOwnProperty shorthand","webpack://vsembed-ai-devtool/webpack/runtime/make namespace object","webpack://vsembed-ai-devtool/webpack/before-startup","webpack://vsembed-ai-devtool/webpack/startup","webpack://vsembed-ai-devtool/webpack/after-startup"],"sourcesContent":["'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n","'use strict'\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = require('events')\nconst Stream = require('stream')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n","// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = require('zlib').constants ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n","'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n","const optsArg = require('./lib/opts-arg.js')\nconst pathArg = require('./lib/path-arg.js')\n\nconst {mkdirpNative, mkdirpNativeSync} = require('./lib/mkdirp-native.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./lib/mkdirp-manual.js')\nconst {useNative, useNativeSync} = require('./lib/use-native.js')\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n","const {dirname} = require('path')\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n","const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n","const {dirname} = require('path')\nconst {findMade, findMadeSync} = require('./find-made.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./mkdirp-manual.js')\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n","const { promisify } = require('util')\nconst fs = require('fs')\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n","const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = require('path')\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n","const fs = require('fs')\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n","'use strict'\n\n// high-level commands\nexports.c = exports.create = require('./lib/create.js')\nexports.r = exports.replace = require('./lib/replace.js')\nexports.t = exports.list = require('./lib/list.js')\nexports.u = exports.update = require('./lib/update.js')\nexports.x = exports.extract = require('./lib/extract.js')\n\n// classes\nexports.Pack = require('./lib/pack.js')\nexports.Unpack = require('./lib/unpack.js')\nexports.Parse = require('./lib/parse.js')\nexports.ReadEntry = require('./lib/read-entry.js')\nexports.WriteEntry = require('./lib/write-entry.js')\nexports.Header = require('./lib/header.js')\nexports.Pax = require('./lib/pax.js')\nexports.types = require('./lib/types.js')\n","'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function') {\n    cb = files\n  }\n\n  if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n","'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n","// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || require('fs')\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n","'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.set(data)\n    }\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '') {\n      this[TYPE] = '0'\n    }\n    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {\n      this[TYPE] = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = ex[k]\n      }\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off) {\n      off = 0\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined) {\n        this[i] = data[i]\n      }\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type)) {\n      this[TYPE] = types.code.get(type)\n    } else {\n      this[TYPE] = type\n    }\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n","'use strict'\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow'],\n])\n\nmodule.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k],\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n","'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n","'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n","'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\nconst normPath = require('./normalize-windows-path.js')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    }\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er) {\n      cb(er)\n    } else {\n      cSet(cache, dir, true)\n      if (created && doChown) {\n        chownr(created, uid, gid, er => done(er))\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return mkdirp(dir, { mode }).then(made => done(null, made), done)\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory()) {\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      } else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) {\n            return cb(er)\n          }\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink()) {\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      } else {\n        cb(er)\n      }\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code)\n    }\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown) {\n      chownr.sync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode))\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part)) {\n      continue\n    }\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n","'use strict'\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) & ~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400) {\n      mode |= 0o100\n    }\n    if (mode & 0o40) {\n      mode |= 0o10\n    }\n    if (mode & 0o4) {\n      mode |= 0o1\n    }\n  }\n  return mode\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null)\nconst { hasOwnProperty } = Object.prototype\nmodule.exports = s => {\n  if (!hasOwnProperty.call(normalizeCache, s)) {\n    normalizeCache[s] = s.normalize('NFD')\n  }\n  return normalizeCache[s]\n}\n","// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n","'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive')\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n","'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst { nextTick } = require('process')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR = (opt.file && (\n        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    const needSniff = this[UNZIP] === null ||\n      this.brotli === undefined && this[UNZIP] === false\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n\n      // look for gzip header\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = this[UNZIP] === null\n          ? new zlib.Unzip()\n          : new zlib.BrotliDecompress()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)\n        this.write(chunk)\n      }\n    }\n  }\n})\n","// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n","'use strict'\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '') {\n      return null\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined) {\n      return ''\n    }\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k) {\n    return set\n  }\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n","'use strict'\nconst { Minipass } = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n","'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n","// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = require('path').win32\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nmodule.exports = str => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n","'use strict'\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n","'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\nconst DEFAULT_MAX_DEPTH = 1024\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth = typeof opt.maxDepth === 'number'\n      ? opt.maxDepth\n      : DEFAULT_MAX_DEPTH\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    const p = normPath(entry.path)\n    const parts = p.split('/')\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n      parts.splice(0, this.strip)\n      entry.path = parts.join('/')\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth,\n      })\n      return false\n    }\n\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n","'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n","'use strict'\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file) {\n      data.file = this.file\n    }\n    if (this.cwd) {\n      data.cwd = this.cwd\n    }\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else {\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n    }\n  }\n}\n","'use strict'\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':',\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),\n}\n","'use strict'\nconst { Minipass } = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n","'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';","import crypto from 'crypto';\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('md5').update(bytes).digest();\n}\n\nexport default md5;","import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import crypto from 'crypto';\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('sha1').update(bytes).digest();\n}\n\nexport default sha1;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || unsafeStringify(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\nexport default version;","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","import { app, BrowserWindow, ipcMain, Menu, dialog, IpcMainInvokeEvent } from 'electron';\nimport * as path from 'path';\nimport { AIOrchestratorService } from '../services/AIOrchestratorService';\nimport { WorkspaceManager } from '../services/WorkspaceManager';\nimport { SecretsManager } from '../services/SecretsManager';\nimport { RunnerManager } from '../services/RunnerManager';\nimport { SecurityManager } from '../services/SecurityManager';\nclass VSEmbedApplication {\n\tconstructor() {\n\t\tapp.on('ready', this.createMainWindow.bind(this));\n\t\tapp.on('window-all-closed', () => {\n\t\t\tif (process.platform !== 'darwin') {\n\t\t\t\tapp.quit();\n\t\t\t}\n\t\t});\n\t\tapp.on('activate', () => {\n\t\t\tif (this.mainWindow === null) {\n\t\t\t\tthis.createMainWindow();\n\t\t\t}\n\t\t});\n\t\t// ...existing constructor logic (if any)...\n\t}\n\n\tprivate createMainWindow() {\n\t\tthis.mainWindow = new BrowserWindow({\n\t\t\twidth: 1200,\n\t\t\theight: 800,\n\t\t\twebPreferences: {\n\t\t\t\tnodeIntegration: true,\n\t\t\t\tcontextIsolation: false,\n\t\t\t},\n\t\t});\n\t\t// Load renderer output (index.html from .webpack/renderer)\n\t\tconst rendererPath = path.join(__dirname, '../renderer/index.html');\n\t\tthis.mainWindow.loadFile(rendererPath);\n\t\tthis.mainWindow.on('closed', () => {\n\t\t\tthis.mainWindow = null;\n\t\t});\n\t}\n\tprivate mainWindow: BrowserWindow | null = null;\n\tprivate orchestrator = new AIOrchestratorService();\n\tprivate workspaceManager = new WorkspaceManager();\n\tprivate secretsManager = new SecretsManager();\n\tprivate runnerManager = new RunnerManager();\n\tprivate securityManager = new SecurityManager();\n\tprivate vscodeBridge: any = {};\n\tprivate extensionRecommender: any = {};\n\tprivate dockerManager: any = {};\n\tprivate performanceOptimizer: any = {};\n\tprivate aiStream: any = {};\n\tprivate permissionMiddleware: any = { \n\t\tcheckPermission: async () => ({ allowed: true }), \n\t\ton: () => {}, \n\t\tgetPolicies: () => [], \n\t\tupdatePolicy: () => {}, \n\t\tgetAuditLog: () => [] \n\t};\n\n\n\t// Place menu handler methods here, after constructor and before final closing brace\n\tprivate async handleNewWorkspace(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('menu:new-workspace');\n\t}\n\n\tprivate async handleOpenWorkspace(): Promise<void> {\n\t\tconst result = await dialog.showOpenDialog(this.mainWindow!, {\n\t\t\tproperties: ['openDirectory'],\n\t\t\ttitle: 'Select Workspace Directory',\n\t\t});\n\n\t\tif (!result.canceled && result.filePaths.length > 0) {\n\t\t\tconst workspacePath = result.filePaths[0];\n\t\t\tthis.mainWindow?.webContents.send('workspace:open', workspacePath);\n\t\t}\n\t}\n\n\tprivate async handleExportWorkspace(): Promise<void> {\n\t\tconst result = await dialog.showSaveDialog(this.mainWindow!, {\n\t\t\ttitle: 'Export Workspace',\n\t\t\tdefaultPath: 'workspace.tar.gz',\n\t\t\tfilters: [\n\t\t\t\t{ name: 'Workspace Archive', extensions: ['tar.gz', 'zip'] },\n\t\t\t],\n\t\t});\n\n\t\tif (!result.canceled && result.filePath) {\n\t\t\tthis.mainWindow?.webContents.send('workspace:export', result.filePath);\n\t\t}\n\t}\n\n\tprivate async handleSettings(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('menu:settings');\n\t}\n\n\t// Add missing menu handler stubs\n\tprivate handleClearConversation(): void {\n\t\t// TODO: Implement clear conversation logic\n\t}\n\n\tprivate handleChangeModel(): void {\n\t\t// TODO: Implement change model logic\n\t}\n\n\tprivate handleDocumentation(): void {\n\t\t// TODO: Implement documentation logic\n\t}\n\n\tprivate async handleAbout(): Promise<void> {\n\t\tif (!this.mainWindow) return;\n\t\tdialog.showMessageBox(this.mainWindow, {\n\t\t\ttype: 'info',\n\t\t\ttitle: 'About VSEmbed AI DevTool',\n\t\t\tmessage: 'VSEmbed AI DevTool',\n\t\t\tdetail: 'Portable, embeddable AI-powered development environment\\nVersion 0.1.0\\nCopyright (c) 2025 Sheewi',\n\t\t});\n\t}\n\n\tprivate async handleAISettings(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('ai:settings');\n\t}\n\n\tprivate async handleStartRunner(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('runner:start');\n\t}\n\n\tprivate async handleStopRunner(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('runner:stop');\n\t}\n\n\tprivate async handleRestartRunner(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('runner:restart');\n\t}\n\n\tprivate async handleViewLogs(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('runner:view-logs');\n\t}\n\n\tprivate async handleManageSecrets(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('security:manage-secrets');\n\t}\n\n\tprivate async handleViewAuditLog(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('security:view-audit-log');\n\t}\n\n\tprivate async handleSecuritySettings(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('security:settings');\n\t}\n\n\tprivate async handlePerformanceReport(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('performance:report');\n\t}\n\n\tprivate async handleDockerStatus(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('docker:status');\n\t}\n\n\tprivate async handlePermissionAudit(): Promise<void> {\n\t\tthis.mainWindow?.webContents.send('permissions:audit');\n\t}\n\n\tprivate createMenu(): void {\n\t\tconst template: Electron.MenuItemConstructorOptions[] = [\n\t\t\t{\n\t\t\t\tlabel: 'File',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ label: 'New Workspace', click: () => this.handleNewWorkspace() },\n\t\t\t\t\t{ label: 'Open Workspace', click: () => this.handleOpenWorkspace() },\n\t\t\t\t\t{ label: 'Export Workspace', click: () => this.handleExportWorkspace() },\n\t\t\t\t\t{ type: 'separator' },\n\t\t\t\t\t{ label: 'Settings', click: () => this.handleSettings() },\n\t\t\t\t\t{ type: 'separator' },\n\t\t\t\t\t{ role: 'quit' },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Edit',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ role: 'undo' },\n\t\t\t\t\t{ role: 'redo' },\n\t\t\t\t\t{ type: 'separator' },\n\t\t\t\t\t{ role: 'cut' },\n\t\t\t\t\t{ role: 'copy' },\n\t\t\t\t\t{ role: 'paste' },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'AI',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ label: 'Clear Conversation', click: () => this.handleClearConversation?.() },\n\t\t\t\t\t{ label: 'Change Model', click: () => this.handleChangeModel?.() },\n\t\t\t\t\t{ type: 'separator' },\n\t\t\t\t\t{ label: 'AI Settings', click: () => this.handleAISettings() },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Runner',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ label: 'Start', accelerator: 'F5', click: () => this.handleStartRunner() },\n\t\t\t\t\t{ label: 'Stop', accelerator: 'Shift+F5', click: () => this.handleStopRunner() },\n\t\t\t\t\t{ label: 'Restart', accelerator: 'Ctrl+F5', click: () => this.handleRestartRunner() },\n\t\t\t\t\t{ type: 'separator' },\n\t\t\t\t\t{ label: 'View Logs', click: () => this.handleViewLogs() },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Security',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ label: 'Manage Secrets', click: () => this.handleManageSecrets() },\n\t\t\t\t\t{ label: 'View Audit Log', click: () => this.handleViewAuditLog() },\n\t\t\t\t\t{ label: 'Security Settings', click: () => this.handleSecuritySettings() },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Help',\n\t\t\t\tsubmenu: [\n\t\t\t\t\t{ label: 'About', click: () => this.handleAbout() },\n\t\t\t\t\t{ label: 'Documentation', click: () => this.handleDocumentation?.() },\n\t\t\t\t],\n\t\t\t},\n\t\t];\n\t\tconst menu = Menu.buildFromTemplate(template);\n\t\tMenu.setApplicationMenu(menu);\n\t}\n\n\tprivate setupIpcHandlers(): void {\n\t\t// Workspace operations\n\tipcMain.handle('workspace:create', async (event: IpcMainInvokeEvent, name: string, template?: string) => {\n\t\t\treturn await this.workspaceManager.createWorkspace(name, template);\n\t\t});\n\n\tipcMain.handle('workspace:open', async (event: IpcMainInvokeEvent, path: string) => {\n\t\t\treturn await this.workspaceManager.openWorkspace(path);\n\t\t});\n\n\tipcMain.handle('workspace:export', async (event: IpcMainInvokeEvent, targetPath: string) => {\n\t\t\treturn await this.workspaceManager.exportWorkspace(targetPath);\n\t\t});\n\n\tipcMain.handle('workspace:import', async (event: IpcMainInvokeEvent, archivePath: string) => {\n\t\t\treturn await this.workspaceManager.importWorkspace(archivePath);\n\t\t});\n\n\t\t// AI Orchestrator operations\n\tipcMain.handle('ai:process-request', async (event: IpcMainInvokeEvent, userInput: string, context?: any) => {\n\t\t\treturn await this.orchestrator.processRequest(userInput, context);\n\t\t});\n\n\tipcMain.handle('ai:execute-plan', async (event: IpcMainInvokeEvent, planId: string) => {\n\t\t\treturn await this.orchestrator.executeActionPlan(planId);\n\t\t});\n\n\t\tipcMain.handle('ai:get-models', async () => {\n\t\t\treturn await this.orchestrator.getAvailableModels();\n\t\t});\n\n\tipcMain.handle('ai:set-model', async (event: IpcMainInvokeEvent, modelName: string) => {\n\t\t\treturn await this.orchestrator.setModel(modelName);\n\t\t});\n\n\t\t// Runner operations\n\tipcMain.handle('runner:start', async (event: IpcMainInvokeEvent, config?: any) => {\n\t\t\treturn await this.runnerManager.start(config);\n\t\t});\n\n\t\tipcMain.handle('runner:stop', async () => {\n\t\t\treturn await this.runnerManager.stop();\n\t\t});\n\n\t\tipcMain.handle('runner:status', async () => {\n\t\t\treturn await this.runnerManager.status();\n\t\t});\n\n\tipcMain.handle('runner:build', async (event: IpcMainInvokeEvent, config?: any) => {\n\t\t\treturn await this.runnerManager.build(config);\n\t\t});\n\n\t\t// Secrets operations\n\tipcMain.handle('secrets:set', async (event: IpcMainInvokeEvent, key: string, value: string) => {\n\t\t\treturn await this.secretsManager.setSecret(key, value);\n\t\t});\n\n\tipcMain.handle('secrets:get', async (event: IpcMainInvokeEvent, key: string, requester: 'user' | 'ai') => {\n\t\t\treturn await this.secretsManager.getSecret(key, requester);\n\t\t});\n\n\t\tipcMain.handle('secrets:list', async () => {\n\t\t\treturn await this.secretsManager.listSecrets();\n\t\t});\n\n\t\t// Security operations\n\tipcMain.handle('security:request-approval', async (event: IpcMainInvokeEvent, summary: string, riskLevel: string, details?: any) => {\n\t\tconst allowedRiskLevels = ['low', 'medium', 'high', 'critical'] as const;\n\t\ttype RiskLevel = typeof allowedRiskLevels[number];\n\t\tconst castedRiskLevel: RiskLevel = allowedRiskLevels.includes(riskLevel as RiskLevel) ? riskLevel as RiskLevel : 'low';\n\t\treturn await this.securityManager.requestApproval(summary, castedRiskLevel, details);\n\t});\n\n\tipcMain.handle('security:log-action', async (event: IpcMainInvokeEvent, actionType: string, metadata: any, riskLevel?: string) => {\n\t\tconst allowedRiskLevels = ['low', 'medium', 'high', 'critical'] as const;\n\t\ttype RiskLevel = typeof allowedRiskLevels[number];\n\t\tconst castedRiskLevel: RiskLevel | undefined = riskLevel && allowedRiskLevels.includes(riskLevel as RiskLevel) ? riskLevel as RiskLevel : undefined;\n\t\treturn await this.securityManager.logAction(actionType, metadata, castedRiskLevel);\n\t});\n\t}\n\n\tprivate setupNewComponentHandlers(): void {\n\t\t// VS Code Bridge operations\n\tipcMain.handle('vscode:execute-command', async (event: IpcMainInvokeEvent, command: string, args?: any[]) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'vscode.commands', { command, args });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.vscodeBridge.executeCommand(command, args);\n\t\t});\n\n\tipcMain.handle('vscode:get-file-content', async (event: IpcMainInvokeEvent, filePath: string) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'vscode.files.read', { filePath });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.vscodeBridge.getFileContent(filePath);\n\t\t});\n\n\tipcMain.handle('vscode:write-file', async (event: IpcMainInvokeEvent, filePath: string, content: string) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'vscode.files.write', { filePath, content });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.vscodeBridge.writeFile(filePath, content);\n\t\t});\n\n\tipcMain.handle('vscode:get-hover-info', async (event: IpcMainInvokeEvent, filePath: string, position: any) => {\n\t\t\treturn await this.vscodeBridge.getHoverInfo(filePath, position);\n\t\t});\n\n\tipcMain.handle('vscode:get-completions', async (event: IpcMainInvokeEvent, filePath: string, position: any) => {\n\t\t\treturn await this.vscodeBridge.getCompletions(filePath, position);\n\t\t});\n\n\tipcMain.handle('vscode:get-definitions', async (event: IpcMainInvokeEvent, filePath: string, position: any) => {\n\t\t\treturn await this.vscodeBridge.getDefinitions(filePath, position);\n\t\t});\n\n\tipcMain.handle('vscode:get-references', async (event: IpcMainInvokeEvent, filePath: string, position: any) => {\n\t\t\treturn await this.vscodeBridge.getReferences(filePath, position);\n\t\t});\n\n\t\t// Extension operations\n\tipcMain.handle('extensions:recommend', async (event: IpcMainInvokeEvent, context: any) => {\n\t\t\treturn await this.extensionRecommender.recommendExtensions(context);\n\t\t});\n\n\tipcMain.handle('extensions:install', async (event: IpcMainInvokeEvent, extensionId: string) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'extensions.install', { extensionId });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.extensionRecommender.installExtension(extensionId);\n\t\t});\n\n\tipcMain.handle('extensions:get-info', async (event: IpcMainInvokeEvent, extensionId: string) => {\n\t\t\treturn await this.extensionRecommender.getExtensionInfo(extensionId);\n\t\t});\n\n\t\t// Docker sandbox operations\n\tipcMain.handle('docker:create-sandbox', async (event: IpcMainInvokeEvent, extensionId: string, config?: any) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'docker.create', { extensionId, config });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.dockerManager.createExtensionSandbox(extensionId, config);\n\t\t});\n\n\tipcMain.handle('docker:stop-sandbox', async (event: IpcMainInvokeEvent, containerId: string) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'docker.stop', { containerId });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.dockerManager.stopSandbox(containerId);\n\t\t});\n\n\tipcMain.handle('docker:execute-command', async (event: IpcMainInvokeEvent, containerId: string, command: string[]) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'docker.execute', { containerId, command });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn await this.dockerManager.executeSandboxCommand(containerId, command);\n\t\t});\n\n\tipcMain.handle('docker:get-logs', async (event: IpcMainInvokeEvent, containerId: string, tail?: number) => {\n\t\t\treturn await this.dockerManager.getSandboxLogs(containerId, tail);\n\t\t});\n\n\t\tipcMain.handle('docker:list-sandboxes', async () => {\n\t\t\treturn this.dockerManager.listSandboxes();\n\t\t});\n\n\t\tipcMain.handle('docker:get-metrics', async () => {\n\t\t\treturn this.dockerManager.getMetrics();\n\t\t});\n\n\t\t// Performance operations\n\t\tipcMain.handle('performance:get-metrics', async () => {\n\t\t\treturn this.performanceOptimizer.getMetrics();\n\t\t});\n\n\t\tipcMain.handle('performance:generate-report', async () => {\n\t\t\treturn this.performanceOptimizer.generateReport();\n\t\t});\n\n\t\tipcMain.handle('performance:get-recommendations', async () => {\n\t\t\treturn this.performanceOptimizer.getOptimizationRecommendations();\n\t\t});\n\n\t\tipcMain.handle('performance:force-gc', async () => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'performance.gc');\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn this.performanceOptimizer.forceGarbageCollection();\n\t\t});\n\n\t\t// Permission middleware operations\n\tipcMain.handle('permissions:check', async (event: IpcMainInvokeEvent, actor: string, resource: string, context?: any) => {\n\t\t\treturn await this.permissionMiddleware.checkPermission(actor, resource, context);\n\t\t});\n\n\t\tipcMain.handle('permissions:get-policies', async () => {\n\t\t\treturn this.permissionMiddleware.getPolicies();\n\t\t});\n\n\tipcMain.handle('permissions:update-policy', async (event: IpcMainInvokeEvent, policyId: string, updates: any) => {\n\t\t\tconst permission = await this.permissionMiddleware.checkPermission('user', 'permissions.policy.update', { policyId, updates });\n\t\t\tif (!permission.allowed) {\n\t\t\t\tthrow new Error(`Permission denied: ${permission.reason}`);\n\t\t\t}\n\t\t\treturn this.permissionMiddleware.updatePolicy(policyId, updates);\n\t\t});\n\n\tipcMain.handle('permissions:get-audit-log', async (event: IpcMainInvokeEvent, filters?: any) => {\n\t\t\treturn this.permissionMiddleware.getAuditLog(filters);\n\t\t});\n\n\t\t// AI Streaming operations\n\t\tipcMain.handle('ai-stream:get-connection-info', async () => {\n\t\t\treturn {\n\t\t\t\tport: 8081,\n\t\t\t\turl: 'ws://localhost:8081',\n\t\t\t\tconnections: this.aiStream.getActiveConnections(),\n\t\t\t\tstreams: this.aiStream.getActiveStreams()\n\t\t\t};\n\t\t});\n\n\t// Event forwarding from components\n\t// (No menu handler methods should be here; move them below)\n\n\t\t// Forward permission events to renderer\n\t\tthis.permissionMiddleware.on('permissionDenied', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('permissions:denied', data);\n\t\t});\n\n\t\tthis.permissionMiddleware.on('auditEvent', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('permissions:audit-event', data);\n\t\t});\n\n\t\t// Forward VS Code bridge events to renderer\n\t\tthis.vscodeBridge.on('extensionInstalled', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('vscode:extension-installed', data);\n\t\t});\n\n\t\tthis.vscodeBridge.on('languageServerReady', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('vscode:language-server-ready', data);\n\t\t});\n\t\tthis.permissionMiddleware.on('permissionDenied', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('permissions:denied', data);\n\t\t});\n\n\t\tthis.permissionMiddleware.on('auditEvent', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('permissions:audit-event', data);\n\t\t});\n\n\t\t// Forward VS Code bridge events to renderer\n\t\tthis.vscodeBridge.on('extensionInstalled', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('vscode:extension-installed', data);\n\t\t});\n\n\t\tthis.vscodeBridge.on('languageServerReady', (data: any) => {\n\t\t\tthis.mainWindow?.webContents.send('vscode:language-server-ready', data);\n\t\t});\n\t}\n}\n\n// Initialize the application\nnew VSEmbedApplication();\n","import { ActionPlan, PlannedAction, AuditLogEntry } from '../types';\nimport { EditorService } from './EditorService';\nimport { TerminalService } from './TerminalService';\nimport { RunnerManager } from './RunnerManager';\nimport { SecurityManager } from './SecurityManager';\nimport { v4 as uuidv4 } from 'uuid';\n\ninterface AIModel {\n\tname: string;\n\tprovider: 'openai' | 'anthropic' | 'local' | 'azure';\n\tendpoint?: string;\n\tapiKey?: string;\n\tmodel: string;\n}\n\nexport class AIOrchestratorService {\n\tprivate currentModel: AIModel | null = null;\n\tprivate conversationHistory: any[] = [];\n\tprivate activePlans = new Map<string, ActionPlan>();\n\n\tprivate editorService: EditorService;\n\tprivate terminalService: TerminalService;\n\tprivate runnerManager: RunnerManager;\n\tprivate securityManager: SecurityManager;\n\n\tconstructor() {\n\t\tthis.editorService = new EditorService();\n\t\tthis.terminalService = new TerminalService();\n\t\tthis.runnerManager = new RunnerManager();\n\t\tthis.securityManager = new SecurityManager();\n\n\t\t// Set default model\n\t\tthis.currentModel = {\n\t\t\tname: 'GPT-4',\n\t\t\tprovider: 'openai',\n\t\t\tmodel: 'gpt-4',\n\t\t};\n\t}\n\n\tasync processRequest(userInput: string, context?: any): Promise<{ plan: ActionPlan; explanation: string }> {\n\t\ttry {\n\t\t\t// Add user input to conversation history\n\t\t\tthis.conversationHistory.push({\n\t\t\t\trole: 'user',\n\t\t\t\tcontent: userInput,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tcontext,\n\t\t\t});\n\n\t\t\t// Analyze the request and create action plan\n\t\t\tconst plan = await this.createActionPlan(userInput, context);\n\n\t\t\t// Add AI response to conversation history\n\t\t\tthis.conversationHistory.push({\n\t\t\t\trole: 'assistant',\n\t\t\t\tcontent: plan.summary,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tplan_id: plan.id,\n\t\t\t});\n\n\t\t\t// Store the plan\n\t\t\tthis.activePlans.set(plan.id, plan);\n\n\t\t\t// Log the action\n\t\t\tawait this.securityManager.logAction('ai_request_processed', {\n\t\t\t\tuser_input: userInput,\n\t\t\t\tplan_id: plan.id,\n\t\t\t\trisk_level: plan.risk_assessment,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tplan,\n\t\t\t\texplanation: this.generateExplanation(plan),\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to process AI request:', error);\n\t\t\tthrow new Error(`Failed to process request: ${error}`);\n\t\t}\n\t}\n\n\tasync executeActionPlan(planId: string): Promise<boolean> {\n\t\tconst plan = this.activePlans.get(planId);\n\t\tif (!plan) {\n\t\t\tthrow new Error(`Plan ${planId} not found`);\n\t\t}\n\n\t\ttry {\n\t\t\t// Check if plan requires approval and has been approved\n\t\t\tif (plan.requires_approval && !plan.actions.every(action => action.approved)) {\n\t\t\t\tthrow new Error('Plan requires approval for all actions');\n\t\t\t}\n\n\t\t\t// Execute actions in sequence\n\t\t\tfor (const action of plan.actions) {\n\t\t\t\tif (!action.approved) {\n\t\t\t\t\tconsole.log(`Skipping unapproved action: ${action.description}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tawait this.executeAction(action);\n\t\t\t\taction.executed = true;\n\n\t\t\t\t// Log each action execution\n\t\t\t\tawait this.securityManager.logAction('action_executed', {\n\t\t\t\t\tplan_id: planId,\n\t\t\t\t\taction_id: action.id,\n\t\t\t\t\taction_type: action.type,\n\t\t\t\t\tdescription: action.description,\n\t\t\t\t}, action.risk_level);\n\t\t\t}\n\n\t\t\t// Mark plan as completed\n\t\t\tplan.actions.forEach(action => {\n\t\t\t\tif (action.approved) action.executed = true;\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to execute action plan ${planId}:`, error);\n\n\t\t\t// Log failure\n\t\t\tawait this.securityManager.logAction('plan_execution_failed', {\n\t\t\t\tplan_id: planId,\n\t\t\t\terror: error.toString(),\n\t\t\t}, 'high');\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getAvailableModels(): Promise<string[]> {\n\t\t// Return list of available AI models\n\t\treturn [\n\t\t\t'GPT-4',\n\t\t\t'GPT-3.5-turbo',\n\t\t\t'Claude-3-Opus',\n\t\t\t'Claude-3-Sonnet',\n\t\t\t'Local-Llama-3.1',\n\t\t\t'Azure-GPT-4',\n\t\t];\n\t}\n\n\tasync setModel(modelName: string): Promise<boolean> {\n\t\ttry {\n\t\t\t// Model configuration would be loaded from settings\n\t\t\tconst modelConfig = this.getModelConfig(modelName);\n\t\t\tthis.currentModel = modelConfig;\n\n\t\t\tawait this.securityManager.logAction('model_changed', {\n\t\t\t\told_model: this.currentModel?.name,\n\t\t\t\tnew_model: modelName,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to set model:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetHistory(): any[] {\n\t\treturn this.conversationHistory;\n\t}\n\n\tasync clearHistory(): Promise<void> {\n\t\tthis.conversationHistory = [];\n\t\tthis.activePlans.clear();\n\n\t\tawait this.securityManager.logAction('conversation_cleared', {\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t});\n\t}\n\n\tprivate async createActionPlan(userInput: string, context?: any): Promise<ActionPlan> {\n\t\tconst planId = uuidv4();\n\n\t\t// Analyze the user input to determine what actions are needed\n\t\tconst actions = await this.analyzeUserRequest(userInput, context);\n\n\t\t// Assess overall risk level\n\t\tconst riskLevel = this.assessPlanRisk(actions);\n\n\t\t// Determine if approval is required\n\t\tconst requiresApproval = riskLevel !== 'low' || actions.some(action =>\n\t\t\taction.type === 'command' || action.type === 'file_delete'\n\t\t);\n\n\t\tconst plan: ActionPlan = {\n\t\t\tid: planId,\n\t\t\tsummary: this.generatePlanSummary(userInput, actions),\n\t\t\tactions,\n\t\t\trisk_assessment: riskLevel,\n\t\t\trequires_approval: requiresApproval,\n\t\t\testimated_time: this.estimateExecutionTime(actions),\n\t\t};\n\n\t\treturn plan;\n\t}\n\n\tprivate async analyzeUserRequest(userInput: string, context?: any): Promise<PlannedAction[]> {\n\t\tconst actions: PlannedAction[] = [];\n\n\t\t// Simple keyword-based analysis (in a real implementation, this would use the AI model)\n\t\tconst lowerInput = userInput.toLowerCase();\n\n\t\t// File operations\n\t\tif (lowerInput.includes('create') && (lowerInput.includes('file') || lowerInput.includes('component'))) {\n\t\t\tactions.push({\n\t\t\t\tid: uuidv4(),\n\t\t\t\ttype: 'file_create',\n\t\t\t\tdescription: 'Create new file based on user request',\n\t\t\t\tpreview: 'Will create a new file with appropriate content',\n\t\t\t\trisk_level: 'low',\n\t\t\t\tapproved: false,\n\t\t\t\texecuted: false,\n\t\t\t\tmetadata: { userInput, context },\n\t\t\t});\n\t\t}\n\n\t\t// Code editing\n\t\tif (lowerInput.includes('modify') || lowerInput.includes('update') || lowerInput.includes('change')) {\n\t\t\tactions.push({\n\t\t\t\tid: uuidv4(),\n\t\t\t\ttype: 'edit',\n\t\t\t\tdescription: 'Modify existing code based on user request',\n\t\t\t\tpreview: 'Will apply code changes to existing files',\n\t\t\t\trisk_level: 'low',\n\t\t\t\tapproved: false,\n\t\t\t\texecuted: false,\n\t\t\t\tmetadata: { userInput, context },\n\t\t\t});\n\t\t}\n\n\t\t// Command execution\n\t\tif (lowerInput.includes('run') || lowerInput.includes('install') || lowerInput.includes('build')) {\n\t\t\tconst riskLevel = this.assessCommandRisk(userInput);\n\t\t\tactions.push({\n\t\t\t\tid: uuidv4(),\n\t\t\t\ttype: 'command',\n\t\t\t\tdescription: `Execute command: ${this.extractCommand(userInput)}`,\n\t\t\t\tpreview: `Will run: ${this.extractCommand(userInput)}`,\n\t\t\t\trisk_level: riskLevel,\n\t\t\t\tapproved: false,\n\t\t\t\texecuted: false,\n\t\t\t\tmetadata: { command: this.extractCommand(userInput), userInput },\n\t\t\t});\n\t\t}\n\n\t\t// Default action if no specific actions detected\n\t\tif (actions.length === 0) {\n\t\t\tactions.push({\n\t\t\t\tid: uuidv4(),\n\t\t\t\ttype: 'edit',\n\t\t\t\tdescription: 'Analyze request and provide code assistance',\n\t\t\t\tpreview: 'Will analyze the request and provide appropriate assistance',\n\t\t\t\trisk_level: 'low',\n\t\t\t\tapproved: false,\n\t\t\t\texecuted: false,\n\t\t\t\tmetadata: { userInput, context },\n\t\t\t});\n\t\t}\n\n\t\treturn actions;\n\t}\n\n\tprivate async executeAction(action: PlannedAction): Promise<void> {\n\t\tswitch (action.type) {\n\t\t\tcase 'edit':\n\t\t\t\tawait this.executeEditAction(action);\n\t\t\t\tbreak;\n\t\t\tcase 'command':\n\t\t\t\tawait this.executeCommandAction(action);\n\t\t\t\tbreak;\n\t\t\tcase 'file_create':\n\t\t\t\tawait this.executeFileCreateAction(action);\n\t\t\t\tbreak;\n\t\t\tcase 'file_delete':\n\t\t\t\tawait this.executeFileDeleteAction(action);\n\t\t\t\tbreak;\n\t\t\tcase 'file_rename':\n\t\t\t\tawait this.executeFileRenameAction(action);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown action type: ${action.type}`);\n\t\t}\n\t}\n\n\tprivate async executeEditAction(action: PlannedAction): Promise<void> {\n\t\t// This would use the AI model to generate appropriate edits\n\t\t// For now, just log the action\n\t\tconsole.log('Executing edit action:', action.description);\n\n\t\t// In a real implementation, this would:\n\t\t// 1. Use the AI model to generate edits\n\t\t// 2. Apply edits via editorService.applyEdits()\n\t}\n\n\tprivate async executeCommandAction(action: PlannedAction): Promise<void> {\n\t\tconst command = action.metadata.command;\n\t\tconst result = await this.terminalService.exec(command, {\n\t\t\texplanation: action.description,\n\t\t\trequireApproval: action.risk_level !== 'low',\n\t\t\triskLevel: action.risk_level,\n\t\t});\n\n\t\tconsole.log('Command executed:', command, 'Result:', result);\n\t}\n\n\tprivate async executeFileCreateAction(action: PlannedAction): Promise<void> {\n\t\t// This would use the AI model to generate file content\n\t\t// For now, create a placeholder file\n\t\tconst fileName = this.extractFileName(action.metadata.userInput) || 'new-file.txt';\n\t\tconst content = await this.generateFileContent(action.metadata.userInput);\n\n\t\tawait this.editorService.createFile(fileName, content);\n\t}\n\n\tprivate async executeFileDeleteAction(action: PlannedAction): Promise<void> {\n\t\tconst fileName = action.metadata.fileName;\n\t\tawait this.editorService.deleteFile(fileName);\n\t}\n\n\tprivate async executeFileRenameAction(action: PlannedAction): Promise<void> {\n\t\tconst { oldPath, newPath } = action.metadata;\n\t\tawait this.editorService.renameFile(oldPath, newPath);\n\t}\n\n\tprivate generatePlanSummary(userInput: string, actions: PlannedAction[]): string {\n\t\tconst actionTypes = actions.map(a => a.type).join(', ');\n\t\treturn `Plan to address: \"${userInput}\". Actions: ${actionTypes}`;\n\t}\n\n\tprivate generateExplanation(plan: ActionPlan): string {\n\t\tlet explanation = `I've created a plan with ${plan.actions.length} action(s):\\n\\n`;\n\n\t\tplan.actions.forEach((action, index) => {\n\t\t\texplanation += `${index + 1}. ${action.description} (Risk: ${action.risk_level})\\n`;\n\t\t});\n\n\t\texplanation += `\\nOverall risk assessment: ${plan.risk_assessment}`;\n\n\t\tif (plan.requires_approval) {\n\t\t\texplanation += '\\n\\nThis plan requires your approval before execution.';\n\t\t}\n\n\t\treturn explanation;\n\t}\n\n\tprivate assessPlanRisk(actions: PlannedAction[]): 'low' | 'medium' | 'high' | 'critical' {\n\t\tconst riskLevels = actions.map(a => a.risk_level);\n\n\t\tif (riskLevels.includes('critical')) return 'critical';\n\t\tif (riskLevels.includes('high')) return 'high';\n\t\tif (riskLevels.includes('medium')) return 'medium';\n\t\treturn 'low';\n\t}\n\n\tprivate assessCommandRisk(input: string): 'low' | 'medium' | 'high' | 'critical' {\n\t\tconst dangerous = ['rm -rf', 'sudo', 'chmod 777', 'format', 'del /f'];\n\t\tconst install = ['npm install', 'pip install', 'yarn add'];\n\n\t\tif (dangerous.some(cmd => input.toLowerCase().includes(cmd.toLowerCase()))) {\n\t\t\treturn 'critical';\n\t\t}\n\n\t\tif (install.some(cmd => input.toLowerCase().includes(cmd.toLowerCase()))) {\n\t\t\treturn 'medium';\n\t\t}\n\n\t\treturn 'low';\n\t}\n\n\tprivate extractCommand(input: string): string {\n\t\t// Simple command extraction\n\t\tconst commands = ['npm install', 'npm start', 'npm run', 'python', 'node', 'yarn', 'pip install'];\n\n\t\tfor (const cmd of commands) {\n\t\t\tif (input.toLowerCase().includes(cmd)) {\n\t\t\t\treturn cmd;\n\t\t\t}\n\t\t}\n\n\t\treturn 'command';\n\t}\n\n\tprivate extractFileName(input: string): string | null {\n\t\t// Simple filename extraction\n\t\tconst match = input.match(/(?:create|file|component)\\s+([a-zA-Z0-9_.-]+)/i);\n\t\treturn match ? match[1] : null;\n\t}\n\n\tprivate async generateFileContent(userInput: string): Promise<string> {\n\t\t// This would use the AI model to generate appropriate content\n\t\t// For now, return a simple placeholder\n\t\treturn `// Generated by VSEmbed AI DevTool\n// User request: ${userInput}\n\n// Your code here\nconsole.log('Hello from VSEmbed AI DevTool!');\n`;\n\t}\n\n\tprivate estimateExecutionTime(actions: PlannedAction[]): number {\n\t\t// Estimate execution time in seconds\n\t\tlet totalTime = 0;\n\n\t\tactions.forEach(action => {\n\t\t\tswitch (action.type) {\n\t\t\t\tcase 'edit':\n\t\t\t\t\ttotalTime += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'file_create':\n\t\t\t\t\ttotalTime += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'command':\n\t\t\t\t\ttotalTime += 10; // Commands can take longer\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttotalTime += 3;\n\t\t\t}\n\t\t});\n\n\t\treturn totalTime;\n\t}\n\n\tprivate getModelConfig(modelName: string): AIModel {\n\t\t// This would load from configuration\n\t\tconst configs: { [key: string]: AIModel } = {\n\t\t\t'GPT-4': {\n\t\t\t\tname: 'GPT-4',\n\t\t\t\tprovider: 'openai',\n\t\t\t\tmodel: 'gpt-4',\n\t\t\t},\n\t\t\t'GPT-3.5-turbo': {\n\t\t\t\tname: 'GPT-3.5-turbo',\n\t\t\t\tprovider: 'openai',\n\t\t\t\tmodel: 'gpt-3.5-turbo',\n\t\t\t},\n\t\t\t'Claude-3-Opus': {\n\t\t\t\tname: 'Claude-3-Opus',\n\t\t\t\tprovider: 'anthropic',\n\t\t\t\tmodel: 'claude-3-opus-20240229',\n\t\t\t},\n\t\t\t'Local-Llama-3.1': {\n\t\t\t\tname: 'Local-Llama-3.1',\n\t\t\t\tprovider: 'local',\n\t\t\t\tmodel: 'llama-3.1-8b',\n\t\t\t\tendpoint: 'http://localhost:11434',\n\t\t\t},\n\t\t};\n\n\t\treturn configs[modelName] || configs['GPT-4'];\n\t}\n}\n","import { EditorAPI, SearchOptions, SearchResult } from '../api/interfaces';\nimport { Edit } from '../types';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport class EditorService implements EditorAPI {\n\tprivate workspacePath: string | null = null;\n\tprivate openFiles: Map<string, string> = new Map();\n\n\tsetWorkspacePath(workspacePath: string): void {\n\t\tthis.workspacePath = workspacePath;\n\t}\n\n\tasync applyEdits(edits: Edit[]): Promise<boolean> {\n\t\ttry {\n\t\t\t// Group edits by file\n\t\t\tconst editsByFile = new Map<string, Edit[]>();\n\n\t\t\tfor (const edit of edits) {\n\t\t\t\tif (!editsByFile.has(edit.file)) {\n\t\t\t\t\teditsByFile.set(edit.file, []);\n\t\t\t\t}\n\t\t\t\teditsByFile.get(edit.file)!.push(edit);\n\t\t\t}\n\n\t\t\t// Apply edits to each file\n\t\t\tfor (const [filePath, fileEdits] of editsByFile) {\n\t\t\t\tawait this.applyEditsToFile(filePath, fileEdits);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to apply edits:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync createFile(relativePath: string, content: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\n\t\t\t// Ensure directory exists\n\t\t\tawait fs.mkdir(path.dirname(fullPath), { recursive: true });\n\n\t\t\t// Write file\n\t\t\tawait fs.writeFile(fullPath, content, 'utf-8');\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to create file:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync deleteFile(relativePath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\t\t\tawait fs.unlink(fullPath);\n\n\t\t\t// Remove from open files if it was open\n\t\t\tthis.openFiles.delete(relativePath);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to delete file:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync renameFile(oldPath: string, newPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst oldFullPath = this.getFullPath(oldPath);\n\t\t\tconst newFullPath = this.getFullPath(newPath);\n\n\t\t\t// Ensure target directory exists\n\t\t\tawait fs.mkdir(path.dirname(newFullPath), { recursive: true });\n\n\t\t\t// Rename file\n\t\t\tawait fs.rename(oldFullPath, newFullPath);\n\n\t\t\t// Update open files map\n\t\t\tif (this.openFiles.has(oldPath)) {\n\t\t\t\tconst content = this.openFiles.get(oldPath)!;\n\t\t\t\tthis.openFiles.delete(oldPath);\n\t\t\t\tthis.openFiles.set(newPath, content);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to rename file:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync search(query: string, options?: SearchOptions): Promise<SearchResult[]> {\n\t\ttry {\n\t\t\tconst results: SearchResult[] = [];\n\t\t\tconst files = await this.getFiles(options?.includePattern);\n\n\t\t\tconst searchRegex = options?.regex\n\t\t\t\t? new RegExp(query, options.caseSensitive ? 'g' : 'gi')\n\t\t\t\t: new RegExp(this.escapeRegex(query), options?.caseSensitive ? 'g' : 'gi');\n\n\t\t\tfor (const file of files) {\n\t\t\t\tif (options?.excludePattern && this.matchesPattern(file, options.excludePattern)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.getFile(file);\n\t\t\t\t\tconst lines = content.split('\\n');\n\n\t\t\t\t\tfor (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n\t\t\t\t\t\tconst line = lines[lineIndex];\n\t\t\t\t\t\tlet match;\n\n\t\t\t\t\t\twhile ((match = searchRegex.exec(line)) !== null) {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tline: lineIndex + 1,\n\t\t\t\t\t\t\t\tcolumn: match.index + 1,\n\t\t\t\t\t\t\t\tmatch: match[0],\n\t\t\t\t\t\t\t\tcontext: this.getLineContext(lines, lineIndex),\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (options?.maxResults && results.length >= options.maxResults) {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (fileError) {\n\t\t\t\t\t// Skip files that can't be read\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to search:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync getFile(relativePath: string): Promise<string> {\n\t\ttry {\n\t\t\t// Check cache first\n\t\t\tif (this.openFiles.has(relativePath)) {\n\t\t\t\treturn this.openFiles.get(relativePath)!;\n\t\t\t}\n\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\t\t\tconst content = await fs.readFile(fullPath, 'utf-8');\n\n\t\t\t// Cache the content\n\t\t\tthis.openFiles.set(relativePath, content);\n\n\t\t\treturn content;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to get file:', error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getFiles(pattern?: string): Promise<string[]> {\n\t\tif (!this.workspacePath) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tconst files = await this.scanDirectory(path.join(this.workspacePath, 'workspace'));\n\n\t\t\tif (pattern) {\n\t\t\t\treturn files.filter(file => this.matchesPattern(file, pattern));\n\t\t\t}\n\n\t\t\treturn files;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to get files:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync openFile(relativePath: string, line?: number, column?: number): Promise<void> {\n\t\ttry {\n\t\t\t// Load file content into cache\n\t\t\tawait this.getFile(relativePath);\n\n\t\t\t// In a real implementation, this would focus the editor on the specific file/line/column\n\t\t\tconsole.log(`Opening file: ${relativePath}`, { line, column });\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to open file:', error);\n\t\t}\n\t}\n\n\tasync getSelection(): Promise<{ file: string; start: any; end: any } | null> {\n\t\t// In a real implementation, this would get the current selection from the editor\n\t\t// For now, return null\n\t\treturn null;\n\t}\n\n\tprivate async applyEditsToFile(filePath: string, edits: Edit[]): Promise<void> {\n\t\tconst content = await this.getFile(filePath);\n\t\tconst lines = content.split('\\n');\n\n\t\t// Sort edits by position (bottom to top) to avoid index shifting\n\t\tconst sortedEdits = edits.sort((a, b) => {\n\t\t\tif (a.start.line !== b.start.line) {\n\t\t\t\treturn b.start.line - a.start.line;\n\t\t\t}\n\t\t\treturn b.start.character - a.start.character;\n\t\t});\n\n\t\t// Apply each edit\n\t\tfor (const edit of sortedEdits) {\n\t\t\tswitch (edit.type) {\n\t\t\t\tcase 'insert':\n\t\t\t\t\tthis.insertText(lines, edit.start, edit.replacement);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'replace':\n\t\t\t\t\tthis.replaceText(lines, edit.start, edit.end, edit.replacement);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\t\tthis.deleteText(lines, edit.start, edit.end);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Update content\n\t\tconst newContent = lines.join('\\n');\n\t\tthis.openFiles.set(filePath, newContent);\n\n\t\t// Write to disk\n\t\tconst fullPath = this.getFullPath(filePath);\n\t\tawait fs.writeFile(fullPath, newContent, 'utf-8');\n\t}\n\n\tprivate insertText(lines: string[], position: { line: number; character: number }, text: string): void {\n\t\tconst lineIndex = position.line - 1;\n\t\tconst line = lines[lineIndex] || '';\n\n\t\tconst before = line.substring(0, position.character);\n\t\tconst after = line.substring(position.character);\n\n\t\tconst insertLines = text.split('\\n');\n\n\t\tif (insertLines.length === 1) {\n\t\t\tlines[lineIndex] = before + text + after;\n\t\t} else {\n\t\t\tlines[lineIndex] = before + insertLines[0];\n\n\t\t\tfor (let i = 1; i < insertLines.length - 1; i++) {\n\t\t\t\tlines.splice(lineIndex + i, 0, insertLines[i]);\n\t\t\t}\n\n\t\t\tlines.splice(lineIndex + insertLines.length - 1, 0, insertLines[insertLines.length - 1] + after);\n\t\t}\n\t}\n\n\tprivate replaceText(\n\t\tlines: string[],\n\t\tstart: { line: number; character: number },\n\t\tend: { line: number; character: number },\n\t\treplacement: string\n\t): void {\n\t\t// First delete the range, then insert the replacement\n\t\tthis.deleteText(lines, start, end);\n\t\tthis.insertText(lines, start, replacement);\n\t}\n\n\tprivate deleteText(\n\t\tlines: string[],\n\t\tstart: { line: number; character: number },\n\t\tend: { line: number; character: number }\n\t): void {\n\t\tconst startLineIndex = start.line - 1;\n\t\tconst endLineIndex = end.line - 1;\n\n\t\tif (startLineIndex === endLineIndex) {\n\t\t\t// Single line deletion\n\t\t\tconst line = lines[startLineIndex];\n\t\t\tconst before = line.substring(0, start.character);\n\t\t\tconst after = line.substring(end.character);\n\t\t\tlines[startLineIndex] = before + after;\n\t\t} else {\n\t\t\t// Multi-line deletion\n\t\t\tconst startLine = lines[startLineIndex];\n\t\t\tconst endLine = lines[endLineIndex];\n\n\t\t\tconst before = startLine.substring(0, start.character);\n\t\t\tconst after = endLine.substring(end.character);\n\n\t\t\t// Remove lines in between\n\t\t\tlines.splice(startLineIndex, endLineIndex - startLineIndex + 1, before + after);\n\t\t}\n\t}\n\n\tprivate getFullPath(relativePath: string): string {\n\t\tif (!this.workspacePath) {\n\t\t\tthrow new Error('No workspace path set');\n\t\t}\n\n\t\treturn path.join(this.workspacePath, 'workspace', relativePath);\n\t}\n\n\tprivate async scanDirectory(dirPath: string): Promise<string[]> {\n\t\tconst files: string[] = [];\n\n\t\ttry {\n\t\t\tconst entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst fullPath = path.join(dirPath, entry.name);\n\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\t// Skip certain directories\n\t\t\t\t\tif (['.git', 'node_modules', '.devstudio'].includes(entry.name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst subFiles = await this.scanDirectory(fullPath);\n\t\t\t\t\tfiles.push(...subFiles);\n\t\t\t\t} else if (entry.isFile()) {\n\t\t\t\t\t// Make path relative to workspace\n\t\t\t\t\tconst relativePath = path.relative(\n\t\t\t\t\t\tpath.join(this.workspacePath!, 'workspace'),\n\t\t\t\t\t\tfullPath\n\t\t\t\t\t);\n\t\t\t\t\tfiles.push(relativePath);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Directory might not exist or be readable\n\t\t\tconsole.warn('Failed to scan directory:', dirPath, error);\n\t\t}\n\n\t\treturn files;\n\t}\n\n\tprivate matchesPattern(filePath: string, pattern: string): boolean {\n\t\t// Simple glob pattern matching\n\t\tconst regexPattern = pattern\n\t\t\t.replace(/\\./g, '\\\\.')\n\t\t\t.replace(/\\*/g, '.*')\n\t\t\t.replace(/\\?/g, '.');\n\n\t\tconst regex = new RegExp(`^${regexPattern}$`, 'i');\n\t\treturn regex.test(filePath);\n\t}\n\n\tprivate escapeRegex(text: string): string {\n\t\treturn text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\t}\n\n\tprivate getLineContext(lines: string[], lineIndex: number): string {\n\t\tconst contextLines = 2;\n\t\tconst start = Math.max(0, lineIndex - contextLines);\n\t\tconst end = Math.min(lines.length, lineIndex + contextLines + 1);\n\n\t\treturn lines.slice(start, end).join('\\n');\n\t}\n\n\t// Additional utility methods\n\tasync saveFile(relativePath: string, content: string): Promise<boolean> {\n\t\ttry {\n\t\t\tthis.openFiles.set(relativePath, content);\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\t\t\tawait fs.writeFile(fullPath, content, 'utf-8');\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to save file:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync fileExists(relativePath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\t\t\tawait fs.access(fullPath);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getFileStats(relativePath: string): Promise<{ size: number; modified: Date } | null> {\n\t\ttry {\n\t\t\tconst fullPath = this.getFullPath(relativePath);\n\t\t\tconst stats = await fs.stat(fullPath);\n\t\t\treturn {\n\t\t\t\tsize: stats.size,\n\t\t\t\tmodified: stats.mtime,\n\t\t\t};\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclearCache(): void {\n\t\tthis.openFiles.clear();\n\t}\n}\n","import { RunnerAPI } from '../api/interfaces';\nimport { RunnerConfig, RunnerStatus, BuildResult } from '../types';\nimport { TerminalService } from './TerminalService';\nimport * as Docker from 'dockerode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport class RunnerManager implements RunnerAPI {\n\tprivate docker: Docker | null = null;\n\tprivate currentContainer: Docker.Container | null = null;\n\tprivate currentStatus: RunnerStatus;\n\tprivate terminalService: TerminalService;\n\tprivate workspacePath: string | null = null;\n\n\tconstructor() {\n\t\tthis.terminalService = new TerminalService();\n\t\tthis.currentStatus = {\n\t\t\trunning: false,\n\t\t\tports: {},\n\t\t\tresource_usage: {\n\t\t\t\tcpu_percent: 0,\n\t\t\t\tmemory_mb: 0,\n\t\t\t\tdisk_mb: 0,\n\t\t\t},\n\t\t\tlast_build: {\n\t\t\t\tsuccess: false,\n\t\t\t\toutput: '',\n\t\t\t\terrors: [],\n\t\t\t\twarnings: [],\n\t\t\t\tartifacts: [],\n\t\t\t},\n\t\t};\n\n\t\tthis.initializeDocker();\n\t}\n\n\tsetWorkspacePath(workspacePath: string): void {\n\t\tthis.workspacePath = workspacePath;\n\t\tthis.terminalService.setWorkspacePath(workspacePath);\n\t}\n\n\tprivate async initializeDocker(): Promise<void> {\n\t\ttry {\n\t\t\tthis.docker = new Docker();\n\n\t\t\t// Test Docker connection\n\t\t\tawait this.docker.ping();\n\t\t\tconsole.log('Docker connection established');\n\t\t} catch (error) {\n\t\t\tconsole.warn('Docker not available, falling back to local runner:', error);\n\t\t\tthis.docker = null;\n\t\t}\n\t}\n\n\tasync build(config?: RunnerConfig): Promise<BuildResult> {\n\t\ttry {\n\t\t\tconst buildConfig = config || await this.getDefaultConfig();\n\n\t\t\tlet buildResult: BuildResult;\n\n\t\t\tif (this.docker && buildConfig.type === 'docker') {\n\t\t\t\tbuildResult = await this.buildWithDocker(buildConfig);\n\t\t\t} else {\n\t\t\t\tbuildResult = await this.buildLocally(buildConfig);\n\t\t\t}\n\n\t\t\tthis.currentStatus.last_build = buildResult;\n\t\t\treturn buildResult;\n\t\t} catch (error) {\n\t\t\tconst buildResult: BuildResult = {\n\t\t\t\tsuccess: false,\n\t\t\t\toutput: '',\n\t\t\t\terrors: [error instanceof Error ? error.message : String(error)],\n\t\t\t\twarnings: [],\n\t\t\t\tartifacts: [],\n\t\t\t};\n\n\t\t\tthis.currentStatus.last_build = buildResult;\n\t\t\treturn buildResult;\n\t\t}\n\t}\n\n\tasync start(config?: RunnerConfig): Promise<RunnerStatus> {\n\t\ttry {\n\t\t\tconst runConfig = config || await this.getDefaultConfig();\n\n\t\t\tif (this.docker && runConfig.type === 'docker') {\n\t\t\t\tawait this.startWithDocker(runConfig);\n\t\t\t} else {\n\t\t\t\tawait this.startLocally(runConfig);\n\t\t\t}\n\n\t\t\tthis.currentStatus.running = true;\n\t\t\treturn this.currentStatus;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to start runner:', error);\n\t\t\tthis.currentStatus.running = false;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync stop(): Promise<boolean> {\n\t\ttry {\n\t\t\tif (this.currentContainer) {\n\t\t\t\tawait this.currentContainer.stop();\n\t\t\t\tawait this.currentContainer.remove();\n\t\t\t\tthis.currentContainer = null;\n\t\t\t}\n\n\t\t\t// Kill any local processes\n\t\t\tconst processes = await this.terminalService.getProcesses();\n\t\t\tfor (const proc of processes) {\n\t\t\t\tawait this.terminalService.kill(proc.pid);\n\t\t\t}\n\n\t\t\tthis.currentStatus.running = false;\n\t\t\tthis.currentStatus.ports = {};\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to stop runner:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync status(): Promise<RunnerStatus> {\n\t\tif (this.currentContainer) {\n\t\t\ttry {\n\t\t\t\tconst containerInfo = await this.currentContainer.inspect();\n\t\t\t\tthis.currentStatus.running = containerInfo.State.Running;\n\n\t\t\t\t// Get resource usage\n\t\t\t\tconst stats = await this.currentContainer.stats({ stream: false });\n\t\t\t\tthis.updateResourceUsage(stats);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Failed to get container status:', error);\n\t\t\t\tthis.currentStatus.running = false;\n\t\t\t}\n\t\t}\n\n\t\treturn { ...this.currentStatus };\n\t}\n\n\tasync exposePort(localPort: number, containerPort: number): Promise<boolean> {\n\t\ttry {\n\t\t\tthis.currentStatus.ports[localPort] = containerPort;\n\n\t\t\t// Update preview URL if this is the main port\n\t\t\tif (!this.currentStatus.preview_url || localPort === 3000 || localPort === 8000) {\n\t\t\t\tthis.currentStatus.preview_url = `http://localhost:${localPort}`;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to expose port:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getLogs(lines: number = 100): Promise<string> {\n\t\ttry {\n\t\t\tif (this.currentContainer) {\n\t\t\t\tconst logs = await this.currentContainer.logs({\n\t\t\t\t\tstdout: true,\n\t\t\t\t\tstderr: true,\n\t\t\t\t\ttail: lines,\n\t\t\t\t\ttimestamps: true,\n\t\t\t\t});\n\t\t\t\treturn logs.toString();\n\t\t\t}\n\n\t\t\t// For local runner, return recent terminal output\n\t\t\treturn 'Local runner logs not implemented yet';\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to get logs:', error);\n\t\t\treturn `Error getting logs: ${error}`;\n\t\t}\n\t}\n\n\tasync restart(): Promise<RunnerStatus> {\n\t\tawait this.stop();\n\t\treturn await this.start();\n\t}\n\n\tprivate async buildWithDocker(config: RunnerConfig): Promise<BuildResult> {\n\t\tif (!this.docker || !this.workspacePath) {\n\t\t\tthrow new Error('Docker not available or workspace not set');\n\t\t}\n\n\t\tconst buildOutput: string[] = [];\n\t\tconst errors: string[] = [];\n\t\tconst warnings: string[] = [];\n\n\t\ttry {\n\t\t\t// Create Dockerfile if it doesn't exist\n\t\t\tawait this.ensureDockerfile(config);\n\n\t\t\t// Build Docker image\n\t\t\tconst buildContext = path.join(this.workspacePath, 'workspace');\n\t\t\tconst tarStream = await this.createBuildContext(buildContext);\n\n\t\t\tconst buildStream = await this.docker.buildImage(tarStream, {\n\t\t\t\tt: `vsembed-workspace:${Date.now()}`,\n\t\t\t\tdockerfile: 'Dockerfile',\n\t\t\t});\n\n\t\t\t// Parse build output\n\t\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\t\tthis.docker!.modem.followProgress(buildStream, (err, res) => {\n\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\telse resolve();\n\t\t\t\t}, (event) => {\n\t\t\t\t\tif (event.stream) {\n\t\t\t\t\t\tbuildOutput.push(event.stream);\n\n\t\t\t\t\t\tif (event.stream.toLowerCase().includes('warning')) {\n\t\t\t\t\t\t\twarnings.push(event.stream.trim());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event.error) {\n\t\t\t\t\t\terrors.push(event.error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: errors.length === 0,\n\t\t\t\toutput: buildOutput.join(''),\n\t\t\t\terrors,\n\t\t\t\twarnings,\n\t\t\t\tartifacts: ['Docker image built successfully'],\n\t\t\t};\n\t\t} catch (error) {\n\t\t\terrors.push(error instanceof Error ? error.message : String(error));\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\toutput: buildOutput.join(''),\n\t\t\t\terrors,\n\t\t\t\twarnings,\n\t\t\t\tartifacts: [],\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate async buildLocally(config: RunnerConfig): Promise<BuildResult> {\n\t\tconst buildCommands = this.getBuildCommands(config);\n\t\tlet allOutput = '';\n\t\tconst errors: string[] = [];\n\t\tconst warnings: string[] = [];\n\n\t\tfor (const command of buildCommands) {\n\t\t\ttry {\n\t\t\t\tconst result = await this.terminalService.exec(command, {\n\t\t\t\t\texplanation: `Build step: ${command}`,\n\t\t\t\t\trequireApproval: false,\n\t\t\t\t\triskLevel: 'low',\n\t\t\t\t\ttimeout: 300000, // 5 minutes\n\t\t\t\t});\n\n\t\t\t\tallOutput += result.stdout + '\\n' + result.stderr + '\\n';\n\n\t\t\t\tif (result.code !== 0) {\n\t\t\t\t\terrors.push(`Command failed: ${command}\\n${result.stderr}`);\n\t\t\t\t}\n\n\t\t\t\t// Check for warnings in output\n\t\t\t\tif (result.stderr && result.stderr.toLowerCase().includes('warning')) {\n\t\t\t\t\twarnings.push(result.stderr);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\terrors.push(`Failed to execute ${command}: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: errors.length === 0,\n\t\t\toutput: allOutput,\n\t\t\terrors,\n\t\t\twarnings,\n\t\t\tartifacts: ['Local build completed'],\n\t\t};\n\t}\n\n\tprivate async startWithDocker(config: RunnerConfig): Promise<void> {\n\t\tif (!this.docker) {\n\t\t\tthrow new Error('Docker not available');\n\t\t}\n\n\t\t// Stop existing container\n\t\tif (this.currentContainer) {\n\t\t\tawait this.stop();\n\t\t}\n\n\t\t// Create and start new container\n\t\tconst portBindings: { [key: string]: any } = {};\n\t\tfor (const [localPort, containerPort] of Object.entries(config.ports)) {\n\t\t\tportBindings[`${containerPort}/tcp`] = [{ HostPort: localPort.toString() }];\n\t\t}\n\n\t\tthis.currentContainer = await this.docker.createContainer({\n\t\t\tImage: config.image || 'node:18-alpine',\n\t\t\tWorkingDir: '/workspace',\n\t\t\tCmd: this.getStartCommand(config),\n\t\t\tEnv: Object.entries(config.environment).map(([key, value]) => `${key}=${value}`),\n\t\t\tHostConfig: {\n\t\t\t\tPortBindings: portBindings,\n\t\t\t\tMemory: this.parseMemoryLimit(config.resource_limits.memory),\n\t\t\t\tCpuQuota: this.parseCpuLimit(config.resource_limits.cpu),\n\t\t\t\tBinds: [`${path.join(this.workspacePath!, 'workspace')}:/workspace`],\n\t\t\t},\n\t\t\tExposedPorts: Object.fromEntries(\n\t\t\t\tObject.values(config.ports).map(port => [`${port}/tcp`, {}])\n\t\t\t),\n\t\t});\n\n\t\tawait this.currentContainer.start();\n\n\t\t// Update status\n\t\tfor (const [localPort, containerPort] of Object.entries(config.ports)) {\n\t\t\tthis.currentStatus.ports[parseInt(localPort)] = containerPort;\n\t\t}\n\t}\n\n\tprivate async startLocally(config: RunnerConfig): Promise<void> {\n\t\tconst startCommands = this.getStartCommands(config);\n\n\t\tfor (const command of startCommands) {\n\t\t\ttry {\n\t\t\t\t// Start command in background for servers\n\t\t\t\tconst isServerCommand = command.includes('start') || command.includes('serve') || command.includes('server');\n\n\t\t\t\tif (isServerCommand) {\n\t\t\t\t\t// Don't await server commands - they run indefinitely\n\t\t\t\t\tthis.terminalService.exec(command, {\n\t\t\t\t\t\texplanation: `Start server: ${command}`,\n\t\t\t\t\t\trequireApproval: false,\n\t\t\t\t\t\triskLevel: 'low',\n\t\t\t\t\t\ttimeout: 0, // No timeout for servers\n\t\t\t\t\t}).catch(console.error);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.terminalService.exec(command, {\n\t\t\t\t\t\texplanation: `Start command: ${command}`,\n\t\t\t\t\t\trequireApproval: false,\n\t\t\t\t\t\triskLevel: 'low',\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Failed to execute start command ${command}:`, error);\n\t\t\t}\n\t\t}\n\n\t\t// Set up default ports for local development\n\t\tthis.currentStatus.ports = config.ports;\n\t\tif (Object.keys(config.ports).length > 0) {\n\t\t\tconst firstPort = Object.keys(config.ports)[0];\n\t\t\tthis.currentStatus.preview_url = `http://localhost:${firstPort}`;\n\t\t}\n\t}\n\n\tprivate async getDefaultConfig(): Promise<RunnerConfig> {\n\t\tconst runtime = await this.detectRuntime();\n\n\t\treturn {\n\t\t\ttype: this.docker ? 'docker' : 'local',\n\t\t\timage: this.getDefaultImage(runtime),\n\t\t\tports: this.getDefaultPorts(runtime),\n\t\t\tenvironment: {\n\t\t\t\tNODE_ENV: 'development',\n\t\t\t\tPORT: '3000',\n\t\t\t\t...process.env,\n\t\t\t},\n\t\t\tworking_directory: '/workspace',\n\t\t\tresource_limits: {\n\t\t\t\tcpu: '1.0',\n\t\t\t\tmemory: '512m',\n\t\t\t\tdisk: '1g',\n\t\t\t},\n\t\t\tnetwork_policy: {\n\t\t\t\tenabled: true,\n\t\t\t\tallowed_hosts: ['localhost', '127.0.0.1'],\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate async detectRuntime(): Promise<string> {\n\t\tif (!this.workspacePath) return 'nodejs';\n\n\t\ttry {\n\t\t\tconst workspaceContent = path.join(this.workspacePath, 'workspace');\n\n\t\t\t// Check for package.json (Node.js)\n\t\t\ttry {\n\t\t\t\tawait fs.access(path.join(workspaceContent, 'package.json'));\n\t\t\t\treturn 'nodejs';\n\t\t\t} catch { }\n\n\t\t\t// Check for requirements.txt (Python)\n\t\t\ttry {\n\t\t\t\tawait fs.access(path.join(workspaceContent, 'requirements.txt'));\n\t\t\t\treturn 'python';\n\t\t\t} catch { }\n\n\t\t\t// Check for main.py (Python)\n\t\t\ttry {\n\t\t\t\tawait fs.access(path.join(workspaceContent, 'main.py'));\n\t\t\t\treturn 'python';\n\t\t\t} catch { }\n\n\t\t\t// Default to Node.js\n\t\t\treturn 'nodejs';\n\t\t} catch {\n\t\t\treturn 'nodejs';\n\t\t}\n\t}\n\n\tprivate getDefaultImage(runtime: string): string {\n\t\tconst images = {\n\t\t\tnodejs: 'node:18-alpine',\n\t\t\tpython: 'python:3.11-alpine',\n\t\t\tdocker: 'alpine:latest',\n\t\t};\n\n\t\treturn images[runtime] || images.nodejs;\n\t}\n\n\tprivate getDefaultPorts(runtime: string): { [localPort: number]: number } {\n\t\tswitch (runtime) {\n\t\t\tcase 'nodejs':\n\t\t\t\treturn { 3000: 3000 };\n\t\t\tcase 'python':\n\t\t\t\treturn { 8000: 8000 };\n\t\t\tdefault:\n\t\t\t\treturn { 3000: 3000 };\n\t\t}\n\t}\n\n\tprivate getBuildCommands(config: RunnerConfig): string[] {\n\t\t// Detect project type and return appropriate build commands\n\t\tif (config.environment.NODE_ENV) {\n\t\t\treturn ['npm install', 'npm run build'];\n\t\t}\n\n\t\t// Python projects\n\t\treturn ['pip install -r requirements.txt'];\n\t}\n\n\tprivate getStartCommands(config: RunnerConfig): string[] {\n\t\t// Detect project type and return appropriate start commands\n\t\tif (config.environment.NODE_ENV) {\n\t\t\treturn ['npm start'];\n\t\t}\n\n\t\t// Python projects\n\t\treturn ['python main.py'];\n\t}\n\n\tprivate getStartCommand(config: RunnerConfig): string[] {\n\t\treturn this.getStartCommands(config);\n\t}\n\n\tprivate async ensureDockerfile(config: RunnerConfig): Promise<void> {\n\t\tif (!this.workspacePath) return;\n\n\t\tconst dockerfilePath = path.join(this.workspacePath, 'workspace', 'Dockerfile');\n\n\t\ttry {\n\t\t\tawait fs.access(dockerfilePath);\n\t\t\t// Dockerfile exists, no need to create\n\t\t} catch {\n\t\t\t// Create default Dockerfile\n\t\t\tconst dockerfile = this.generateDockerfile(config);\n\t\t\tawait fs.writeFile(dockerfilePath, dockerfile);\n\t\t}\n\t}\n\n\tprivate generateDockerfile(config: RunnerConfig): string {\n\t\tconst runtime = config.image?.includes('node') ? 'nodejs' : 'python';\n\n\t\tif (runtime === 'nodejs') {\n\t\t\treturn `FROM ${config.image || 'node:18-alpine'}\n\nWORKDIR /workspace\n\nCOPY package*.json ./\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [\"npm\", \"start\"]\n`;\n\t\t} else {\n\t\t\treturn `FROM ${config.image || 'python:3.11-alpine'}\n\nWORKDIR /workspace\n\nCOPY requirements.txt ./\nRUN pip install -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"python\", \"main.py\"]\n`;\n\t\t}\n\t}\n\n\tprivate async createBuildContext(contextPath: string): Promise<NodeJS.ReadableStream> {\n\t\tconst tar = require('tar');\n\n\t\treturn tar.create({\n\t\t\tgzip: false,\n\t\t\tcwd: contextPath,\n\t\t}, ['.']);\n\t}\n\n\tprivate parseMemoryLimit(limit: string): number {\n\t\tconst match = limit.match(/(\\d+)([kmg]?)/i);\n\t\tif (!match) return 512 * 1024 * 1024; // Default 512MB\n\n\t\tconst value = parseInt(match[1]);\n\t\tconst unit = match[2]?.toLowerCase() || '';\n\n\t\tswitch (unit) {\n\t\t\tcase 'k': return value * 1024;\n\t\t\tcase 'm': return value * 1024 * 1024;\n\t\t\tcase 'g': return value * 1024 * 1024 * 1024;\n\t\t\tdefault: return value;\n\t\t}\n\t}\n\n\tprivate parseCpuLimit(limit: string): number {\n\t\tconst value = parseFloat(limit);\n\t\treturn Math.floor(value * 100000); // Docker CPU quota in microseconds\n\t}\n\n\tprivate updateResourceUsage(stats: any): void {\n\t\ttry {\n\t\t\t// Parse Docker stats\n\t\t\tconst cpuPercent = this.calculateCpuPercent(stats);\n\t\t\tconst memoryMB = stats.memory_stats?.usage ?\n\t\t\t\tMath.round(stats.memory_stats.usage / (1024 * 1024)) : 0;\n\n\t\t\tthis.currentStatus.resource_usage = {\n\t\t\t\tcpu_percent: cpuPercent,\n\t\t\t\tmemory_mb: memoryMB,\n\t\t\t\tdisk_mb: 0, // Docker doesn't provide disk usage easily\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to update resource usage:', error);\n\t\t}\n\t}\n\n\tprivate calculateCpuPercent(stats: any): number {\n\t\ttry {\n\t\t\tconst cpuDelta = stats.cpu_stats.cpu_usage.total_usage -\n\t\t\t\t(stats.precpu_stats?.cpu_usage?.total_usage || 0);\n\t\t\tconst systemDelta = stats.cpu_stats.system_cpu_usage -\n\t\t\t\t(stats.precpu_stats?.system_cpu_usage || 0);\n\n\t\t\tif (systemDelta > 0 && cpuDelta > 0) {\n\t\t\t\treturn Math.round((cpuDelta / systemDelta) * 100);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t} catch {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n","import * as crypto from 'crypto';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\ninterface EncryptedSecret {\n\tiv: string;\n\tencryptedData: string;\n\tauthTag: string;\n}\n\ninterface SecretsStore {\n\tversion: string;\n\tsecrets: { [key: string]: EncryptedSecret };\n\tcreated: string;\n\tlastModified: string;\n}\n\nexport class SecretsManager {\n\tprivate readonly secretsDir = path.join(os.homedir(), '.vsembed', 'secrets');\n\tprivate readonly secretsFile = path.join(this.secretsDir, 'secrets.json');\n\tprivate passphrase: string | null = null;\n\tprivate secretsStore: SecretsStore | null = null;\n\n\tconstructor() {\n\t\tthis.ensureSecretsDirectory();\n\t}\n\n\tprivate async ensureSecretsDirectory(): Promise<void> {\n\t\ttry {\n\t\t\tawait fs.mkdir(this.secretsDir, { recursive: true });\n\n\t\t\t// Set restrictive permissions on secrets directory\n\t\t\tawait fs.chmod(this.secretsDir, 0o700);\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to create secrets directory:', error);\n\t\t}\n\t}\n\n\tasync setSecret(key: string, value: string): Promise<boolean> {\n\t\ttry {\n\t\t\tif (!this.passphrase) {\n\t\t\t\tthis.passphrase = await this.getPassphrase();\n\t\t\t}\n\n\t\t\tawait this.loadSecretsStore();\n\n\t\t\t// Encrypt the secret\n\t\t\tconst encrypted = this.encryptSecret(value, this.passphrase);\n\n\t\t\t// Store the encrypted secret\n\t\t\tthis.secretsStore!.secrets[key] = encrypted;\n\t\t\tthis.secretsStore!.lastModified = new Date().toISOString();\n\n\t\t\t// Save to disk\n\t\t\tawait this.saveSecretsStore();\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to set secret:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getSecret(key: string, requester: 'user' | 'ai'): Promise<string | null> {\n\t\ttry {\n\t\t\tif (!this.passphrase) {\n\t\t\t\tthis.passphrase = await this.getPassphrase();\n\t\t\t}\n\n\t\t\tawait this.loadSecretsStore();\n\n\t\t\tconst encryptedSecret = this.secretsStore?.secrets[key];\n\t\t\tif (!encryptedSecret) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// For AI requests, require explicit user approval\n\t\t\tif (requester === 'ai') {\n\t\t\t\tconst approved = await this.requestSecretApproval(key);\n\t\t\t\tif (!approved) {\n\t\t\t\t\tconsole.log(`Secret access denied for AI request: ${key}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Decrypt the secret\n\t\t\tconst decrypted = this.decryptSecret(encryptedSecret, this.passphrase);\n\t\t\treturn decrypted;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to get secret:', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync deleteSecret(key: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait this.loadSecretsStore();\n\n\t\t\tif (!this.secretsStore?.secrets[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tdelete this.secretsStore.secrets[key];\n\t\t\tthis.secretsStore.lastModified = new Date().toISOString();\n\n\t\t\tawait this.saveSecretsStore();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to delete secret:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync listSecrets(): Promise<string[]> {\n\t\ttry {\n\t\t\tawait this.loadSecretsStore();\n\t\t\treturn Object.keys(this.secretsStore?.secrets || {});\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to list secrets:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync hasSecret(key: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait this.loadSecretsStore();\n\t\t\treturn key in (this.secretsStore?.secrets || {});\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to check secret existence:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync changePassphrase(oldPassphrase: string, newPassphrase: string): Promise<boolean> {\n\t\ttry {\n\t\t\t// Verify old passphrase\n\t\t\tthis.passphrase = oldPassphrase;\n\t\t\tawait this.loadSecretsStore();\n\n\t\t\t// Re-encrypt all secrets with new passphrase\n\t\t\tconst secrets = this.secretsStore!.secrets;\n\t\t\tconst reencryptedSecrets: { [key: string]: EncryptedSecret } = {};\n\n\t\t\tfor (const [key, encryptedSecret] of Object.entries(secrets)) {\n\t\t\t\tconst decrypted = this.decryptSecret(encryptedSecret, oldPassphrase);\n\t\t\t\treencryptedSecrets[key] = this.encryptSecret(decrypted, newPassphrase);\n\t\t\t}\n\n\t\t\t// Update store\n\t\t\tthis.secretsStore!.secrets = reencryptedSecrets;\n\t\t\tthis.secretsStore!.lastModified = new Date().toISOString();\n\t\t\tthis.passphrase = newPassphrase;\n\n\t\t\tawait this.saveSecretsStore();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to change passphrase:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync exportSecrets(): Promise<{ keys: string[]; warning: string }> {\n\t\tconst keys = await this.listSecrets();\n\t\treturn {\n\t\t\tkeys,\n\t\t\twarning: 'Secret values are encrypted and cannot be exported. Only keys are listed.',\n\t\t};\n\t}\n\n\tprivate async loadSecretsStore(): Promise<void> {\n\t\ttry {\n\t\t\tconst data = await fs.readFile(this.secretsFile, 'utf-8');\n\t\t\tthis.secretsStore = JSON.parse(data);\n\t\t} catch (error) {\n\t\t\tif ((error as any).code === 'ENOENT') {\n\t\t\t\t// Create new store if file doesn't exist\n\t\t\t\tthis.secretsStore = {\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t\tsecrets: {},\n\t\t\t\t\tcreated: new Date().toISOString(),\n\t\t\t\t\tlastModified: new Date().toISOString(),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async saveSecretsStore(): Promise<void> {\n\t\tif (!this.secretsStore) {\n\t\t\tthrow new Error('No secrets store to save');\n\t\t}\n\n\t\tconst data = JSON.stringify(this.secretsStore, null, 2);\n\t\tawait fs.writeFile(this.secretsFile, data);\n\n\t\t// Set restrictive permissions on secrets file\n\t\tawait fs.chmod(this.secretsFile, 0o600);\n\t}\n\n\tprivate encryptSecret(secret: string, passphrase: string): EncryptedSecret {\n\t\t// Derive key from passphrase\n\t\tconst salt = crypto.randomBytes(32);\n\t\tconst key = crypto.scryptSync(passphrase, salt, 32);\n\n\t\t// Generate IV\n\t\tconst iv = crypto.randomBytes(16);\n\n\t\t// Create cipher\n\t\tconst cipher = crypto.createCipherGCM('aes-256-gcm', key);\n\t\tcipher.setAAD(salt); // Use salt as additional authenticated data\n\n\t\tlet encrypted = cipher.update(secret, 'utf8', 'hex');\n\t\tencrypted += cipher.final('hex');\n\n\t\tconst authTag = cipher.getAuthTag();\n\n\t\treturn {\n\t\t\tiv: Buffer.concat([salt, iv]).toString('hex'),\n\t\t\tencryptedData: encrypted,\n\t\t\tauthTag: authTag.toString('hex'),\n\t\t};\n\t}\n\n\tprivate decryptSecret(encryptedSecret: EncryptedSecret, passphrase: string): string {\n\t\t// Extract salt and IV\n\t\tconst ivBuffer = Buffer.from(encryptedSecret.iv, 'hex');\n\t\tconst salt = ivBuffer.subarray(0, 32);\n\t\tconst iv = ivBuffer.subarray(32, 48);\n\n\t\t// Derive key from passphrase\n\t\tconst key = crypto.scryptSync(passphrase, salt, 32);\n\n\t\t// Create decipher\n\t\tconst decipher = crypto.createDecipherGCM('aes-256-gcm', key);\n\t\tdecipher.setAAD(salt);\n\t\tdecipher.setAuthTag(Buffer.from(encryptedSecret.authTag, 'hex'));\n\n\t\tlet decrypted = decipher.update(encryptedSecret.encryptedData, 'hex', 'utf8');\n\t\tdecrypted += decipher.final('utf8');\n\n\t\treturn decrypted;\n\t}\n\n\tprivate async getPassphrase(): Promise<string> {\n\t\t// In a real implementation, this would prompt the user for their passphrase\n\t\t// For now, use a default or environment variable\n\t\tconst passphrase = process.env.VSEMBED_SECRETS_PASSPHRASE;\n\n\t\tif (!passphrase) {\n\t\t\tthrow new Error('No passphrase provided. Set VSEMBED_SECRETS_PASSPHRASE environment variable or implement user prompt.');\n\t\t}\n\n\t\treturn passphrase;\n\t}\n\n\tprivate async requestSecretApproval(key: string): Promise<boolean> {\n\t\t// In a real implementation, this would show a dialog to the user\n\t\t// asking for permission to access the secret\n\t\tconsole.log(`AI requesting access to secret: ${key}`);\n\n\t\t// For now, return false (deny access) for security\n\t\t// This should be implemented as a proper user dialog\n\t\treturn false;\n\t}\n\n\t// Utility methods for integration with OS keyring (future enhancement)\n\tprivate async storeInKeyring(key: string, value: string): Promise<boolean> {\n\t\t// This would integrate with OS keyring (Keychain on macOS, Credential Manager on Windows, etc.)\n\t\t// For now, just log the intention\n\t\tconsole.log(`Would store ${key} in OS keyring`);\n\t\treturn true;\n\t}\n\n\tprivate async getFromKeyring(key: string): Promise<string | null> {\n\t\t// This would retrieve from OS keyring\n\t\tconsole.log(`Would retrieve ${key} from OS keyring`);\n\t\treturn null;\n\t}\n\n\tasync clearAllSecrets(): Promise<boolean> {\n\t\ttry {\n\t\t\tthis.secretsStore = {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsecrets: {},\n\t\t\t\tcreated: new Date().toISOString(),\n\t\t\t\tlastModified: new Date().toISOString(),\n\t\t\t};\n\n\t\t\tawait this.saveSecretsStore();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to clear all secrets:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync backupSecrets(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait this.loadSecretsStore();\n\n\t\t\t// Create backup (still encrypted)\n\t\t\tconst backupData = JSON.stringify(this.secretsStore, null, 2);\n\t\t\tawait fs.writeFile(backupPath, backupData);\n\n\t\t\t// Set restrictive permissions\n\t\t\tawait fs.chmod(backupPath, 0o600);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to backup secrets:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync restoreSecrets(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupData = await fs.readFile(backupPath, 'utf-8');\n\t\t\tconst backupStore = JSON.parse(backupData) as SecretsStore;\n\n\t\t\t// Validate backup structure\n\t\t\tif (!backupStore.version || !backupStore.secrets) {\n\t\t\t\tthrow new Error('Invalid backup file format');\n\t\t\t}\n\n\t\t\tthis.secretsStore = backupStore;\n\t\t\tthis.secretsStore.lastModified = new Date().toISOString();\n\n\t\t\tawait this.saveSecretsStore();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to restore secrets:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n}\n","import { AuditLogEntry } from '../types';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { v4 as uuidv4 } from 'uuid';\nimport { dialog } from 'electron';\n\nexport class SecurityManager {\n\tprivate readonly auditLogPath = path.join(os.homedir(), '.vsembed', 'audit.log');\n\tprivate auditLog: AuditLogEntry[] = [];\n\n\tconstructor() {\n\t\tthis.loadAuditLog();\n\t}\n\n\tasync requestApproval(\n\t\tsummary: string,\n\t\triskLevel: 'low' | 'medium' | 'high' | 'critical',\n\t\tdetails?: any\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\t// Log the approval request\n\t\t\tawait this.logAction('approval_requested', {\n\t\t\t\tsummary,\n\t\t\t\trisk_level: riskLevel,\n\t\t\t\tdetails,\n\t\t\t}, riskLevel);\n\n\t\t\t// Show approval dialog to user\n\t\t\tconst approved = await this.showApprovalDialog(summary, riskLevel, details);\n\n\t\t\t// Log the approval result\n\t\t\tawait this.logAction(approved ? 'approval_granted' : 'approval_denied', {\n\t\t\t\tsummary,\n\t\t\t\trisk_level: riskLevel,\n\t\t\t\tapproved,\n\t\t\t}, riskLevel);\n\n\t\t\treturn approved;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to request approval:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync logAction(\n\t\tactionType: string,\n\t\tmetadata: any,\n\t\triskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low'\n\t): Promise<void> {\n\t\tconst entry: AuditLogEntry = {\n\t\t\tid: uuidv4(),\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\taction_type: actionType,\n\t\t\tuser_initiated: this.isUserInitiated(actionType),\n\t\t\tai_initiated: this.isAIInitiated(actionType),\n\t\t\tsummary: this.generateActionSummary(actionType, metadata),\n\t\t\tmetadata,\n\t\t\trisk_level: riskLevel,\n\t\t\tapproved: this.wasApproved(actionType, metadata),\n\t\t\texecuted: this.wasExecuted(actionType, metadata),\n\t\t};\n\n\t\tthis.auditLog.push(entry);\n\t\tawait this.saveAuditLog();\n\t}\n\n\tasync getAuditLog(\n\t\tstartDate?: Date,\n\t\tendDate?: Date,\n\t\tactionType?: string\n\t): Promise<AuditLogEntry[]> {\n\t\tlet filteredLog = [...this.auditLog];\n\n\t\tif (startDate) {\n\t\t\tfilteredLog = filteredLog.filter(entry =>\n\t\t\t\tnew Date(entry.timestamp) >= startDate\n\t\t\t);\n\t\t}\n\n\t\tif (endDate) {\n\t\t\tfilteredLog = filteredLog.filter(entry =>\n\t\t\t\tnew Date(entry.timestamp) <= endDate\n\t\t\t);\n\t\t}\n\n\t\tif (actionType) {\n\t\t\tfilteredLog = filteredLog.filter(entry =>\n\t\t\t\tentry.action_type === actionType\n\t\t\t);\n\t\t}\n\n\t\treturn filteredLog.sort((a, b) =>\n\t\t\tnew Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n\t\t);\n\t}\n\n\tasync clearAuditLog(): Promise<void> {\n\t\t// Request approval for clearing audit log (high-risk action)\n\t\tconst approved = await this.requestApproval(\n\t\t\t'Clear entire audit log',\n\t\t\t'high',\n\t\t\t{ action: 'clear_audit_log', entries_count: this.auditLog.length }\n\t\t);\n\n\t\tif (approved) {\n\t\t\tthis.auditLog = [];\n\t\t\tawait this.saveAuditLog();\n\t\t}\n\t}\n\n\tasync exportAuditLog(filePath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst exportData = {\n\t\t\t\texport_timestamp: new Date().toISOString(),\n\t\t\t\ttotal_entries: this.auditLog.length,\n\t\t\t\tentries: this.auditLog,\n\t\t\t};\n\n\t\t\tawait fs.writeFile(filePath, JSON.stringify(exportData, null, 2));\n\n\t\t\tawait this.logAction('audit_log_exported', {\n\t\t\t\tfile_path: filePath,\n\t\t\t\tentries_count: this.auditLog.length,\n\t\t\t});\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to export audit log:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync validateActionSecurity(actionType: string, metadata: any): Promise<{\n\t\tallowed: boolean;\n\t\triskLevel: 'low' | 'medium' | 'high' | 'critical';\n\t\treason: string;\n\t}> {\n\t\tconst securityCheck = this.performSecurityCheck(actionType, metadata);\n\n\t\tawait this.logAction('security_validation', {\n\t\t\taction_type: actionType,\n\t\t\tvalidation_result: securityCheck,\n\t\t\tmetadata,\n\t\t}, securityCheck.riskLevel);\n\n\t\treturn securityCheck;\n\t}\n\n\tasync checkRateLimit(actionType: string): Promise<boolean> {\n\t\tconst now = new Date();\n\t\tconst oneMinuteAgo = new Date(now.getTime() - 60000);\n\n\t\tconst recentActions = this.auditLog.filter(entry =>\n\t\t\tentry.action_type === actionType &&\n\t\t\tnew Date(entry.timestamp) > oneMinuteAgo\n\t\t);\n\n\t\tconst limit = this.getRateLimit(actionType);\n\t\tconst allowed = recentActions.length < limit;\n\n\t\tif (!allowed) {\n\t\t\tawait this.logAction('rate_limit_exceeded', {\n\t\t\t\taction_type: actionType,\n\t\t\t\trecent_count: recentActions.length,\n\t\t\t\tlimit,\n\t\t\t}, 'medium');\n\t\t}\n\n\t\treturn allowed;\n\t}\n\n\tprivate async showApprovalDialog(\n\t\tsummary: string,\n\t\triskLevel: 'low' | 'medium' | 'high' | 'critical',\n\t\tdetails?: any\n\t): Promise<boolean> {\n\t\tconst riskColors = {\n\t\t\tlow: '🟢',\n\t\t\tmedium: '🟡',\n\t\t\thigh: '🟠',\n\t\t\tcritical: '🔴',\n\t\t};\n\n\t\tconst message = `${riskColors[riskLevel]} AI Action Approval Required\\n\\n${summary}`;\n\n\t\tlet detailText = '';\n\t\tif (details) {\n\t\t\tdetailText = `\\n\\nDetails:\\n${JSON.stringify(details, null, 2)}`;\n\t\t}\n\n\t\tconst result = await dialog.showMessageBox({\n\t\t\ttype: riskLevel === 'critical' ? 'error' :\n\t\t\t\triskLevel === 'high' ? 'warning' : 'question',\n\t\t\ttitle: 'AI Action Approval',\n\t\t\tmessage,\n\t\t\tdetail: detailText,\n\t\t\tbuttons: ['Approve', 'Deny'],\n\t\t\tdefaultId: 1, // Default to deny for security\n\t\t\tcancelId: 1,\n\t\t});\n\n\t\treturn result.response === 0; // 0 = Approve\n\t}\n\n\tprivate isUserInitiated(actionType: string): boolean {\n\t\tconst userInitiatedActions = [\n\t\t\t'user_request',\n\t\t\t'file_opened',\n\t\t\t'settings_changed',\n\t\t\t'approval_granted',\n\t\t\t'approval_denied',\n\t\t\t'workspace_created',\n\t\t\t'workspace_opened',\n\t\t];\n\n\t\treturn userInitiatedActions.includes(actionType);\n\t}\n\n\tprivate isAIInitiated(actionType: string): boolean {\n\t\tconst aiInitiatedActions = [\n\t\t\t'ai_request_processed',\n\t\t\t'action_executed',\n\t\t\t'file_created',\n\t\t\t'file_modified',\n\t\t\t'command_executed',\n\t\t];\n\n\t\treturn aiInitiatedActions.includes(actionType);\n\t}\n\n\tprivate generateActionSummary(actionType: string, metadata: any): string {\n\t\tswitch (actionType) {\n\t\t\tcase 'ai_request_processed':\n\t\t\t\treturn `AI processed request: ${metadata.user_input?.substring(0, 50)}...`;\n\t\t\tcase 'action_executed':\n\t\t\t\treturn `Executed action: ${metadata.action_type} - ${metadata.description}`;\n\t\t\tcase 'file_created':\n\t\t\t\treturn `File created: ${metadata.file_path}`;\n\t\t\tcase 'file_modified':\n\t\t\t\treturn `File modified: ${metadata.file_path}`;\n\t\t\tcase 'command_executed':\n\t\t\t\treturn `Command executed: ${metadata.command}`;\n\t\t\tcase 'approval_requested':\n\t\t\t\treturn `Approval requested: ${metadata.summary}`;\n\t\t\tcase 'approval_granted':\n\t\t\t\treturn `Approval granted: ${metadata.summary}`;\n\t\t\tcase 'approval_denied':\n\t\t\t\treturn `Approval denied: ${metadata.summary}`;\n\t\t\tcase 'security_validation':\n\t\t\t\treturn `Security validation: ${metadata.action_type} - ${metadata.validation_result.reason}`;\n\t\t\tcase 'rate_limit_exceeded':\n\t\t\t\treturn `Rate limit exceeded for: ${metadata.action_type}`;\n\t\t\tdefault:\n\t\t\t\treturn `Action: ${actionType}`;\n\t\t}\n\t}\n\n\tprivate wasApproved(actionType: string, metadata: any): boolean {\n\t\treturn actionType === 'approval_granted' ||\n\t\t\tmetadata.approved === true ||\n\t\t\tthis.isLowRiskAction(actionType);\n\t}\n\n\tprivate wasExecuted(actionType: string, metadata: any): boolean {\n\t\tconst executedActions = [\n\t\t\t'action_executed',\n\t\t\t'file_created',\n\t\t\t'file_modified',\n\t\t\t'command_executed',\n\t\t];\n\n\t\treturn executedActions.includes(actionType) || metadata.executed === true;\n\t}\n\n\tprivate isLowRiskAction(actionType: string): boolean {\n\t\tconst lowRiskActions = [\n\t\t\t'file_opened',\n\t\t\t'search_performed',\n\t\t\t'ai_request_processed',\n\t\t\t'settings_viewed',\n\t\t];\n\n\t\treturn lowRiskActions.includes(actionType);\n\t}\n\n\tprivate performSecurityCheck(actionType: string, metadata: any): {\n\t\tallowed: boolean;\n\t\triskLevel: 'low' | 'medium' | 'high' | 'critical';\n\t\treason: string;\n\t} {\n\t\t// Check for dangerous commands\n\t\tif (actionType === 'command_executed') {\n\t\t\tconst command = metadata.command?.toLowerCase() || '';\n\n\t\t\tif (command.includes('rm -rf') || command.includes('del /f')) {\n\t\t\t\treturn {\n\t\t\t\t\tallowed: false,\n\t\t\t\t\triskLevel: 'critical',\n\t\t\t\t\treason: 'Destructive file deletion command detected',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.includes('sudo') || command.includes('chmod 777')) {\n\t\t\t\treturn {\n\t\t\t\t\tallowed: false,\n\t\t\t\t\triskLevel: 'high',\n\t\t\t\t\treason: 'Privileged command detected',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.includes('install') || command.includes('download')) {\n\t\t\t\treturn {\n\t\t\t\t\tallowed: true,\n\t\t\t\t\triskLevel: 'medium',\n\t\t\t\t\treason: 'Package installation or download command',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check for file operations\n\t\tif (actionType === 'file_delete') {\n\t\t\treturn {\n\t\t\t\tallowed: true,\n\t\t\t\triskLevel: 'medium',\n\t\t\t\treason: 'File deletion operation',\n\t\t\t};\n\t\t}\n\n\t\tif (actionType === 'file_create' || actionType === 'file_modify') {\n\t\t\treturn {\n\t\t\t\tallowed: true,\n\t\t\t\triskLevel: 'low',\n\t\t\t\treason: 'Standard file operation',\n\t\t\t};\n\t\t}\n\n\t\t// Default to low risk for unknown actions\n\t\treturn {\n\t\t\tallowed: true,\n\t\t\triskLevel: 'low',\n\t\t\treason: 'Standard operation',\n\t\t};\n\t}\n\n\tprivate getRateLimit(actionType: string): number {\n\t\tconst rateLimits: { [key: string]: number } = {\n\t\t\tcommand_executed: 10,\n\t\t\tfile_created: 20,\n\t\t\tfile_modified: 50,\n\t\t\tai_request_processed: 30,\n\t\t};\n\n\t\treturn rateLimits[actionType] || 100;\n\t}\n\n\tprivate async loadAuditLog(): Promise<void> {\n\t\ttry {\n\t\t\tconst data = await fs.readFile(this.auditLogPath, 'utf-8');\n\t\t\tthis.auditLog = JSON.parse(data);\n\t\t} catch (error) {\n\t\t\tif ((error as any).code === 'ENOENT') {\n\t\t\t\t// Create empty log if file doesn't exist\n\t\t\t\tthis.auditLog = [];\n\t\t\t} else {\n\t\t\t\tconsole.error('Failed to load audit log:', error);\n\t\t\t\tthis.auditLog = [];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async saveAuditLog(): Promise<void> {\n\t\ttry {\n\t\t\t// Ensure directory exists\n\t\t\tawait fs.mkdir(path.dirname(this.auditLogPath), { recursive: true });\n\n\t\t\t// Keep only last 10000 entries to prevent unlimited growth\n\t\t\tif (this.auditLog.length > 10000) {\n\t\t\t\tthis.auditLog = this.auditLog.slice(-10000);\n\t\t\t}\n\n\t\t\tawait fs.writeFile(this.auditLogPath, JSON.stringify(this.auditLog, null, 2));\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to save audit log:', error);\n\t\t}\n\t}\n}\n","import { TerminalAPI, ExecutionOptions, ExecutionResult, ProcessInfo } from '../api/interfaces';\nimport { spawn, ChildProcess } from 'child_process';\nimport * as path from 'path';\nimport * as os from 'os';\n\nexport class TerminalService implements TerminalAPI {\n\tprivate workingDirectory: string;\n\tprivate environment: { [key: string]: string };\n\tprivate runningProcesses: Map<number, ChildProcess> = new Map();\n\n\tconstructor() {\n\t\tthis.workingDirectory = process.cwd();\n\t\tthis.environment = { ...process.env };\n\t}\n\n\tsetWorkspacePath(workspacePath: string): void {\n\t\tthis.workingDirectory = path.join(workspacePath, 'workspace');\n\t}\n\n\tasync exec(command: string, options: ExecutionOptions): Promise<ExecutionResult> {\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Security check\n\t\t\tif (options.requireApproval) {\n\t\t\t\t// In a real implementation, this would request approval\n\t\t\t\tconsole.log(`Command requires approval: ${command}`);\n\t\t\t}\n\n\t\t\t// Set up execution environment\n\t\t\tconst execEnv = {\n\t\t\t\t...this.environment,\n\t\t\t\t...(options.env || {}),\n\t\t\t};\n\n\t\t\tconst execCwd = options.cwd || this.workingDirectory;\n\t\t\tconst timeout = options.timeout || 30000;\n\n\t\t\t// Execute command\n\t\t\tconst result = await this.executeCommand(command, {\n\t\t\t\tcwd: execCwd,\n\t\t\t\tenv: execEnv,\n\t\t\t\tshell: options.shell || this.getDefaultShell(),\n\t\t\t\ttimeout,\n\t\t\t});\n\n\t\t\tconst executionTime = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tstdout: result.stdout,\n\t\t\t\tstderr: result.stderr,\n\t\t\t\tcode: result.code,\n\t\t\t\ttime: executionTime,\n\t\t\t\tcommand,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst executionTime = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tstdout: '',\n\t\t\t\tstderr: error instanceof Error ? error.message : String(error),\n\t\t\t\tcode: 1,\n\t\t\t\ttime: executionTime,\n\t\t\t\tcommand,\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getCwd(): Promise<string> {\n\t\treturn this.workingDirectory;\n\t}\n\n\tasync setCwd(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\t// Validate path exists\n\t\t\tconst fs = require('fs/promises');\n\t\t\tawait fs.access(path);\n\n\t\t\tthis.workingDirectory = path;\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getEnv(): Promise<{ [key: string]: string }> {\n\t\treturn { ...this.environment };\n\t}\n\n\tasync setEnv(key: string, value: string): Promise<boolean> {\n\t\tthis.environment[key] = value;\n\t\treturn true;\n\t}\n\n\tasync kill(pid: number): Promise<boolean> {\n\t\ttry {\n\t\t\tconst process = this.runningProcesses.get(pid);\n\t\t\tif (process) {\n\t\t\t\tprocess.kill();\n\t\t\t\tthis.runningProcesses.delete(pid);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Try to kill by PID directly\n\t\t\tprocess.kill(pid);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getProcesses(): Promise<ProcessInfo[]> {\n\t\tconst processes: ProcessInfo[] = [];\n\n\t\tfor (const [pid, childProcess] of this.runningProcesses) {\n\t\t\tif (childProcess.pid) {\n\t\t\t\tprocesses.push({\n\t\t\t\t\tpid: childProcess.pid,\n\t\t\t\t\tcommand: childProcess.spawnargs.join(' '),\n\t\t\t\t\tcpu: 0, // Would need ps/wmic to get actual CPU usage\n\t\t\t\t\tmemory: 0, // Would need ps/wmic to get actual memory usage\n\t\t\t\t\tstartTime: new Date().toISOString(), // Approximate\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn processes;\n\t}\n\n\tprivate async executeCommand(command: string, options: {\n\t\tcwd: string;\n\t\tenv: { [key: string]: string };\n\t\tshell: string;\n\t\ttimeout: number;\n\t}): Promise<{ stdout: string; stderr: string; code: number }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet stdout = '';\n\t\t\tlet stderr = '';\n\n\t\t\t// Parse command and arguments\n\t\t\tconst { cmd, args } = this.parseCommand(command);\n\n\t\t\t// Spawn process\n\t\t\tconst childProcess = spawn(cmd, args, {\n\t\t\t\tcwd: options.cwd,\n\t\t\t\tenv: options.env,\n\t\t\t\tshell: options.shell,\n\t\t\t\tstdio: 'pipe',\n\t\t\t});\n\n\t\t\t// Track running process\n\t\t\tif (childProcess.pid) {\n\t\t\t\tthis.runningProcesses.set(childProcess.pid, childProcess);\n\t\t\t}\n\n\t\t\t// Set up timeout\n\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\tchildProcess.kill('SIGTERM');\n\t\t\t\treject(new Error(`Command timed out after ${options.timeout}ms`));\n\t\t\t}, options.timeout);\n\n\t\t\t// Collect output\n\t\t\tif (childProcess.stdout) {\n\t\t\t\tchildProcess.stdout.on('data', (data) => {\n\t\t\t\t\tstdout += data.toString();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (childProcess.stderr) {\n\t\t\t\tchildProcess.stderr.on('data', (data) => {\n\t\t\t\t\tstderr += data.toString();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Handle completion\n\t\t\tchildProcess.on('close', (code) => {\n\t\t\t\tclearTimeout(timeoutId);\n\n\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\tthis.runningProcesses.delete(childProcess.pid);\n\t\t\t\t}\n\n\t\t\t\tresolve({\n\t\t\t\t\tstdout: stdout.trim(),\n\t\t\t\t\tstderr: stderr.trim(),\n\t\t\t\t\tcode: code || 0,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Handle errors\n\t\t\tchildProcess.on('error', (error) => {\n\t\t\t\tclearTimeout(timeoutId);\n\n\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\tthis.runningProcesses.delete(childProcess.pid);\n\t\t\t\t}\n\n\t\t\t\treject(error);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate parseCommand(command: string): { cmd: string; args: string[] } {\n\t\t// Simple command parsing (in production, use a proper shell parser)\n\t\tconst parts = command.trim().split(/\\s+/);\n\t\tconst cmd = parts[0];\n\t\tconst args = parts.slice(1);\n\n\t\treturn { cmd, args };\n\t}\n\n\tprivate getDefaultShell(): string {\n\t\tswitch (os.platform()) {\n\t\t\tcase 'win32':\n\t\t\t\treturn process.env.COMSPEC || 'cmd.exe';\n\t\t\tcase 'darwin':\n\t\t\tcase 'linux':\n\t\t\tdefault:\n\t\t\t\treturn process.env.SHELL || '/bin/sh';\n\t\t}\n\t}\n\n\t// Utility methods for common operations\n\tasync installPackages(packageManager: 'npm' | 'yarn' | 'pip', packages: string[]): Promise<ExecutionResult> {\n\t\tlet command: string;\n\n\t\tswitch (packageManager) {\n\t\t\tcase 'npm':\n\t\t\t\tcommand = `npm install ${packages.join(' ')}`;\n\t\t\t\tbreak;\n\t\t\tcase 'yarn':\n\t\t\t\tcommand = `yarn add ${packages.join(' ')}`;\n\t\t\t\tbreak;\n\t\t\tcase 'pip':\n\t\t\t\tcommand = `pip install ${packages.join(' ')}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported package manager: ${packageManager}`);\n\t\t}\n\n\t\treturn this.exec(command, {\n\t\t\texplanation: `Install packages: ${packages.join(', ')}`,\n\t\t\trequireApproval: true,\n\t\t\triskLevel: 'medium',\n\t\t\ttimeout: 120000, // 2 minutes for package installation\n\t\t});\n\t}\n\n\tasync runScript(script: string): Promise<ExecutionResult> {\n\t\t// Detect script type by extension or shebang\n\t\tconst isNodeScript = script.includes('node ') || script.includes('npm ') || script.includes('yarn ');\n\t\tconst isPythonScript = script.includes('python ') || script.includes('pip ');\n\n\t\tlet riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';\n\n\t\tif (script.includes('install') || script.includes('download')) {\n\t\t\triskLevel = 'medium';\n\t\t}\n\n\t\tif (script.includes('sudo') || script.includes('rm -rf') || script.includes('format')) {\n\t\t\triskLevel = 'critical';\n\t\t}\n\n\t\treturn this.exec(script, {\n\t\t\texplanation: `Run script: ${script}`,\n\t\t\trequireApproval: riskLevel !== 'low',\n\t\t\triskLevel,\n\t\t});\n\t}\n\n\tasync startDevServer(command?: string): Promise<ExecutionResult> {\n\t\tconst defaultCommands = [\n\t\t\t'npm start',\n\t\t\t'npm run dev',\n\t\t\t'yarn start',\n\t\t\t'yarn dev',\n\t\t\t'python -m http.server 8000',\n\t\t\t'python3 -m http.server 8000',\n\t\t];\n\n\t\tconst serverCommand = command || this.detectStartCommand();\n\n\t\treturn this.exec(serverCommand, {\n\t\t\texplanation: `Start development server: ${serverCommand}`,\n\t\t\trequireApproval: false,\n\t\t\triskLevel: 'low',\n\t\t\ttimeout: 60000,\n\t\t});\n\t}\n\n\tprivate detectStartCommand(): string {\n\t\t// In a real implementation, this would check package.json, requirements.txt, etc.\n\t\t// For now, default to npm start\n\t\treturn 'npm start';\n\t}\n\n\tasync checkPorts(ports: number[]): Promise<{ [port: number]: boolean }> {\n\t\tconst result: { [port: number]: boolean } = {};\n\n\t\tfor (const port of ports) {\n\t\t\ttry {\n\t\t\t\tconst command = os.platform() === 'win32'\n\t\t\t\t\t? `netstat -an | findstr :${port}`\n\t\t\t\t\t: `lsof -i :${port}`;\n\n\t\t\t\tconst execResult = await this.exec(command, {\n\t\t\t\t\texplanation: `Check if port ${port} is in use`,\n\t\t\t\t\trequireApproval: false,\n\t\t\t\t\triskLevel: 'low',\n\t\t\t\t});\n\n\t\t\t\tresult[port] = execResult.code === 0 && execResult.stdout.length > 0;\n\t\t\t} catch {\n\t\t\t\tresult[port] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync getSystemInfo(): Promise<any> {\n\t\tconst info: any = {\n\t\t\tplatform: os.platform(),\n\t\t\tarch: os.arch(),\n\t\t\tnodeVersion: process.version,\n\t\t\tcwd: this.workingDirectory,\n\t\t};\n\n\t\ttry {\n\t\t\t// Get additional system info\n\t\t\tconst commands = {\n\t\t\t\tgit: 'git --version',\n\t\t\t\tnode: 'node --version',\n\t\t\t\tnpm: 'npm --version',\n\t\t\t\tpython: 'python --version',\n\t\t\t\tdocker: 'docker --version',\n\t\t\t};\n\n\t\t\tfor (const [tool, command] of Object.entries(commands)) {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await this.exec(command, {\n\t\t\t\t\t\texplanation: `Check ${tool} version`,\n\t\t\t\t\t\trequireApproval: false,\n\t\t\t\t\t\triskLevel: 'low',\n\t\t\t\t\t\ttimeout: 5000,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (result.code === 0) {\n\t\t\t\t\t\tinfo[`${tool}Version`] = result.stdout.trim();\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Tool not available\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to get system info:', error);\n\t\t}\n\n\t\treturn info;\n\t}\n}\n","import { WorkspaceManifest, AiPolicy, SecretsConfig } from '../types';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { v4 as uuidv4 } from 'uuid';\nimport { createReadStream, createWriteStream } from 'fs';\nimport * as tar from 'tar';\n\nexport class WorkspaceManager {\n\tprivate currentWorkspace: string | null = null;\n\tprivate manifest: WorkspaceManifest | null = null;\n\tprivate readonly workspaceDir = path.join(os.homedir(), '.vsembed', 'workspaces');\n\n\tconstructor() {\n\t\tthis.ensureWorkspaceDirectory();\n\t}\n\n\tprivate async ensureWorkspaceDirectory(): Promise<void> {\n\t\ttry {\n\t\t\tawait fs.mkdir(this.workspaceDir, { recursive: true });\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to create workspace directory:', error);\n\t\t}\n\t}\n\n\tasync createWorkspace(name: string, template?: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst workspaceId = uuidv4();\n\t\t\tconst workspacePath = path.join(this.workspaceDir, workspaceId);\n\n\t\t\t// Create workspace directory structure\n\t\t\tawait fs.mkdir(workspacePath, { recursive: true });\n\t\t\tawait fs.mkdir(path.join(workspacePath, 'workspace'), { recursive: true });\n\t\t\tawait fs.mkdir(path.join(workspacePath, '.devstudio'), { recursive: true });\n\t\t\tawait fs.mkdir(path.join(workspacePath, '.devstudio', 'state'), { recursive: true });\n\n\t\t\t// Create default manifest\n\t\t\tconst manifest: WorkspaceManifest = {\n\t\t\t\tworkspace_id: workspaceId,\n\t\t\t\tname,\n\t\t\t\tcreated_at: new Date().toISOString(),\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t\truntime: 'nodejs',\n\t\t\t\trunner: 'docker',\n\t\t\t\textensions: [],\n\t\t\t\tai_policy: this.getDefaultAiPolicy(),\n\t\t\t\tsecrets: {\n\t\t\t\t\tencrypted: true,\n\t\t\t\t\tfile: '.devstudio/secrets.enc',\n\t\t\t\t\tprovider: 'local'\n\t\t\t\t},\n\t\t\t\tversion: '1.0.0'\n\t\t\t};\n\n\t\t\t// Apply template if specified\n\t\t\tif (template) {\n\t\t\t\tawait this.applyTemplate(workspacePath, template);\n\t\t\t}\n\n\t\t\t// Save manifest\n\t\t\tawait this.saveManifest(workspacePath, manifest);\n\n\t\t\tthis.currentWorkspace = workspacePath;\n\t\t\tthis.manifest = manifest;\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to create workspace:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync openWorkspace(workspacePath: string): Promise<boolean> {\n\t\ttry {\n\t\t\t// Check if workspace exists and has manifest\n\t\t\tconst manifestPath = path.join(workspacePath, '.devstudio', 'manifest.json');\n\t\t\tconst manifestContent = await fs.readFile(manifestPath, 'utf-8');\n\t\t\tconst manifest = JSON.parse(manifestContent) as WorkspaceManifest;\n\n\t\t\t// Validate workspace structure\n\t\t\tconst validation = await this.validateWorkspace(workspacePath);\n\t\t\tif (!validation.valid) {\n\t\t\t\tconsole.error('Invalid workspace:', validation.errors);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.currentWorkspace = workspacePath;\n\t\t\tthis.manifest = manifest;\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to open workspace:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync exportWorkspace(targetPath: string): Promise<boolean> {\n\t\tif (!this.currentWorkspace) {\n\t\t\tconsole.error('No workspace currently open');\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Update manifest with current timestamp\n\t\t\tif (this.manifest) {\n\t\t\t\tthis.manifest.updated_at = new Date().toISOString();\n\t\t\t\tawait this.saveManifest(this.currentWorkspace, this.manifest);\n\t\t\t}\n\n\t\t\t// Create tar.gz archive\n\t\t\tawait tar.create(\n\t\t\t\t{\n\t\t\t\t\tgzip: true,\n\t\t\t\t\tfile: targetPath,\n\t\t\t\t\tcwd: path.dirname(this.currentWorkspace),\n\t\t\t\t},\n\t\t\t\t[path.basename(this.currentWorkspace)]\n\t\t\t);\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to export workspace:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync importWorkspace(archivePath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst tempDir = path.join(os.tmpdir(), 'vsembed-import', uuidv4());\n\t\t\tawait fs.mkdir(tempDir, { recursive: true });\n\n\t\t\t// Extract archive\n\t\t\tawait tar.extract({\n\t\t\t\tfile: archivePath,\n\t\t\t\tcwd: tempDir,\n\t\t\t});\n\n\t\t\t// Find the workspace directory in extracted content\n\t\t\tconst contents = await fs.readdir(tempDir);\n\t\t\tif (contents.length !== 1) {\n\t\t\t\tthrow new Error('Archive should contain exactly one workspace directory');\n\t\t\t}\n\n\t\t\tconst extractedWorkspace = path.join(tempDir, contents[0]);\n\n\t\t\t// Validate extracted workspace\n\t\t\tconst validation = await this.validateWorkspace(extractedWorkspace);\n\t\t\tif (!validation.valid) {\n\t\t\t\tthrow new Error(`Invalid workspace: ${validation.errors.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Move to workspace directory\n\t\t\tconst manifest = await this.loadManifest(extractedWorkspace);\n\t\t\tconst targetPath = path.join(this.workspaceDir, manifest.workspace_id);\n\n\t\t\tawait fs.rename(extractedWorkspace, targetPath);\n\n\t\t\t// Clean up temp directory\n\t\t\tawait fs.rmdir(tempDir, { recursive: true });\n\n\t\t\treturn await this.openWorkspace(targetPath);\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to import workspace:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync getManifest(): Promise<WorkspaceManifest | null> {\n\t\treturn this.manifest;\n\t}\n\n\tasync updateManifest(updates: Partial<WorkspaceManifest>): Promise<boolean> {\n\t\tif (!this.currentWorkspace || !this.manifest) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.manifest = {\n\t\t\t\t...this.manifest,\n\t\t\t\t...updates,\n\t\t\t\tupdated_at: new Date().toISOString(),\n\t\t\t};\n\n\t\t\tawait this.saveManifest(this.currentWorkspace, this.manifest);\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to update manifest:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync validateWorkspace(workspacePath?: string): Promise<{ valid: boolean; errors: string[] }> {\n\t\tconst targetPath = workspacePath || this.currentWorkspace;\n\t\tif (!targetPath) {\n\t\t\treturn { valid: false, errors: ['No workspace path provided'] };\n\t\t}\n\n\t\tconst errors: string[] = [];\n\n\t\ttry {\n\t\t\t// Check required directories\n\t\t\tconst requiredDirs = ['workspace', '.devstudio', '.devstudio/state'];\n\t\t\tfor (const dir of requiredDirs) {\n\t\t\t\tconst dirPath = path.join(targetPath, dir);\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.stat(dirPath);\n\t\t\t\t\tif (!stats.isDirectory()) {\n\t\t\t\t\t\terrors.push(`${dir} is not a directory`);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\terrors.push(`Missing required directory: ${dir}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check manifest\n\t\t\ttry {\n\t\t\t\tconst manifest = await this.loadManifest(targetPath);\n\t\t\t\tif (!manifest.workspace_id || !manifest.name || !manifest.version) {\n\t\t\t\t\terrors.push('Invalid manifest: missing required fields');\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\terrors.push('Missing or invalid manifest.json');\n\t\t\t}\n\n\t\t\treturn { valid: errors.length === 0, errors };\n\t\t} catch (error) {\n\t\t\treturn { valid: false, errors: [`Workspace validation failed: ${error}`] };\n\t\t}\n\t}\n\n\tgetCurrentWorkspacePath(): string | null {\n\t\treturn this.currentWorkspace;\n\t}\n\n\tprivate async saveManifest(workspacePath: string, manifest: WorkspaceManifest): Promise<void> {\n\t\tconst manifestPath = path.join(workspacePath, '.devstudio', 'manifest.json');\n\t\tawait fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\n\t}\n\n\tprivate async loadManifest(workspacePath: string): Promise<WorkspaceManifest> {\n\t\tconst manifestPath = path.join(workspacePath, '.devstudio', 'manifest.json');\n\t\tconst content = await fs.readFile(manifestPath, 'utf-8');\n\t\treturn JSON.parse(content);\n\t}\n\n\tprivate getDefaultAiPolicy(): AiPolicy {\n\t\treturn {\n\t\t\tauto_apply_edits: false,\n\t\t\tallow_terminal_commands: false,\n\t\t\trequire_approval_for_installs: true,\n\t\t\trequire_approval_for_destructive: true,\n\t\t\tallow_network_access: false,\n\t\t\tallowed_domains: ['localhost', '127.0.0.1'],\n\t\t\tmax_command_timeout: 30000,\n\t\t};\n\t}\n\n\tprivate async applyTemplate(workspacePath: string, template: string): Promise<void> {\n\t\t// Template application logic would go here\n\t\t// For now, just create a simple structure based on template type\n\t\tconst workspaceContentPath = path.join(workspacePath, 'workspace');\n\n\t\tswitch (template) {\n\t\t\tcase 'nodejs':\n\t\t\t\tawait this.createNodeJsTemplate(workspaceContentPath);\n\t\t\t\tbreak;\n\t\t\tcase 'python':\n\t\t\t\tawait this.createPythonTemplate(workspaceContentPath);\n\t\t\t\tbreak;\n\t\t\tcase 'react':\n\t\t\t\tawait this.createReactTemplate(workspaceContentPath);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Empty template\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate async createNodeJsTemplate(workspacePath: string): Promise<void> {\n\t\tconst packageJson = {\n\t\t\tname: 'my-app',\n\t\t\tversion: '1.0.0',\n\t\t\tdescription: '',\n\t\t\tmain: 'index.js',\n\t\t\tscripts: {\n\t\t\t\tstart: 'node index.js',\n\t\t\t\tdev: 'node index.js',\n\t\t\t},\n\t\t\tdependencies: {},\n\t\t};\n\n\t\tconst indexJs = `console.log('Hello from VSEmbed AI DevTool!');\n\n// Your Node.js application starts here\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/html' });\n  res.end('<h1>Hello from Node.js!</h1><p>This app is running in VSEmbed AI DevTool.</p>');\n});\n\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(\\`Server running on http://localhost:\\${PORT}\\`);\n});\n`;\n\n\t\tawait fs.writeFile(path.join(workspacePath, 'package.json'), JSON.stringify(packageJson, null, 2));\n\t\tawait fs.writeFile(path.join(workspacePath, 'index.js'), indexJs);\n\t\tawait fs.writeFile(path.join(workspacePath, 'README.md'), '# My Node.js App\\n\\nCreated with VSEmbed AI DevTool');\n\t}\n\n\tprivate async createPythonTemplate(workspacePath: string): Promise<void> {\n\t\tconst mainPy = `#!/usr/bin/env python3\n\"\"\"\nHello from VSEmbed AI DevTool!\n\"\"\"\n\nimport http.server\nimport socketserver\nimport os\n\ndef main():\n    PORT = int(os.environ.get('PORT', 8000))\n\n    class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n        def do_GET(self):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<h1>Hello from Python!</h1><p>This app is running in VSEmbed AI DevTool.</p>')\n\n    with socketserver.TCPServer((\"\", PORT), MyHTTPRequestHandler) as httpd:\n        print(f\"Server running on http://localhost:{PORT}\")\n        httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    main()\n`;\n\n\t\tconst requirementsTxt = `# Add your Python dependencies here\n# requests>=2.28.0\n# flask>=2.2.0\n`;\n\n\t\tawait fs.writeFile(path.join(workspacePath, 'main.py'), mainPy);\n\t\tawait fs.writeFile(path.join(workspacePath, 'requirements.txt'), requirementsTxt);\n\t\tawait fs.writeFile(path.join(workspacePath, 'README.md'), '# My Python App\\n\\nCreated with VSEmbed AI DevTool');\n\t}\n\n\tprivate async createReactTemplate(workspacePath: string): Promise<void> {\n\t\t// This would create a basic React setup\n\t\t// For now, just create a package.json that can be expanded by AI\n\t\tconst packageJson = {\n\t\t\tname: 'my-react-app',\n\t\t\tversion: '0.1.0',\n\t\t\tprivate: true,\n\t\t\tdependencies: {\n\t\t\t\treact: '^18.2.0',\n\t\t\t\t'react-dom': '^18.2.0',\n\t\t\t\t'react-scripts': '^5.0.1'\n\t\t\t},\n\t\t\tscripts: {\n\t\t\t\tstart: 'react-scripts start',\n\t\t\t\tbuild: 'react-scripts build',\n\t\t\t\ttest: 'react-scripts test',\n\t\t\t\teject: 'react-scripts eject'\n\t\t\t},\n\t\t\tbrowserslist: {\n\t\t\t\tproduction: ['>0.2%', 'not dead', 'not op_mini all'],\n\t\t\t\tdevelopment: ['last 1 chrome version', 'last 1 firefox version', 'last 1 safari version']\n\t\t\t}\n\t\t};\n\n\t\tawait fs.writeFile(path.join(workspacePath, 'package.json'), JSON.stringify(packageJson, null, 2));\n\t\tawait fs.writeFile(path.join(workspacePath, 'README.md'), '# My React App\\n\\nCreated with VSEmbed AI DevTool');\n\t}\n}\n","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"dockerode\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"fs/promises\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main/main.ts\");\n",""],"names":[],"sourceRoot":""}